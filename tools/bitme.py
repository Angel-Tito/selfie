#!/usr/bin/env python3

# Copyright (c) the Selfie Project authors. All rights reserved.
# Please see the AUTHORS file for details. Use of this source code is
# governed by a BSD license that can be found in the LICENSE file.

# Selfie is a project of the Computational Systems Group at the
# Department of Computer Sciences of the University of Salzburg
# in Austria. For further information and code please refer to:

# selfie.cs.uni-salzburg.at

# Bitme is a bounded model checker for BTOR2 models using
# the Z3 and bitwuzla SMT solvers as reasoning engines.

# Bitme is designed to work with BTOR2 models generated by rotor
# for modeling RISC-V machines and RISC-V code. Rotor is a tool
# that is part of the selfie system.

# ------------------------------------------------------------

# for debugging segfaults: import faulthandler; faulthandler.enable()

import btor2

import ctypes

try:
    rotor = ctypes.cdll.LoadLibrary("rotor")
    is_rotor_present = True
except OSError:
    print("rotor is not available")
    is_rotor_present = False

# requires Z3 and the Z3 Python API:
# pip install z3-solver

try:
    import z3
    is_Z3_present = True
except ImportError:
    print("Z3 is not available")
    is_Z3_present = False

# requires bitwuzla and the bitwuzla Python API:
# cd bitwuzla
# pip install .

try:
    import bitwuzla
    is_bitwuzla_present = True
except ImportError:
    print("bitwuzla is not available")
    is_bitwuzla_present = False

import math

class BVDD:
    def __init__(self, i2v):
        self.i2v = i2v

    def __str__(self):
        return f"{self.i2v}"

    def number_of_inputs(self):
        return len(self.i2v)

    def number_of_values(self):
        return len(set(self.i2v.values()))

    def is_never_false(self):
        return self.number_of_values() == 1 and True in self.i2v.values()

    def is_never_true(self):
        return self.number_of_values() == 1 and False in self.i2v.values()

    def constant(output_value):
        assert isinstance(output_value, bool) or isinstance(output_value, int)
        return BVDD(dict([(input_value, output_value) for input_value in range(256)]))

    def projection():
        return BVDD(dict([(input_value, input_value) for input_value in range(256)]))

    def compute_unary(self, op):
        return BVDD(dict([(input_value, op(self.i2v[input_value])) for input_value in self.i2v]))

    def compute_binary(self, op, bvdd2):
        assert isinstance(bvdd2, BVDD)
        bvdd1 = self
        return BVDD(dict([(input_value, op(bvdd1.i2v[input_value], bvdd2.i2v[input_value])) for input_value in bvdd1.i2v.keys() & bvdd2.i2v.keys()]))

    def compute_ite(self, bvdd2, bvdd3):
        assert isinstance(bvdd2, BVDD) and isinstance(bvdd3, BVDD)
        bvdd1 = self
        return BVDD(dict([(input_value, bvdd2.i2v[input_value] if bvdd1.i2v[input_value] else bvdd3.i2v[input_value])
            for input_value in bvdd1.i2v.keys() & (bvdd2.i2v.keys() | bvdd3.i2v.keys())]))

    def get_printed_BVDD(self, value):
        return [input_value for input_value in self.i2v if self.i2v[input_value] == value]

class ROABVDD_Exit:
    bump = 0

    exits = {}
    exit_hits = 0

    def new():
        ID = ROABVDD_Exit.bump
        if ID not in ROABVDD_Exit.exits:
            exit = ROABVDD_Exit(ID)
            ROABVDD_Exit.exits[ID] = exit
        else:
            ROABVDD_Exit.exit_hits += 1
            exit = ROABVDD_Exit.exits[ID]
        ROABVDD_Exit.bump += 1
        return exit

    def __init__(self, ID):
        self.ID = ID

    def __repr__(self):
        return f"Exit({self.ID})"

    def number_of_inputs(self):
        return 0

    def number_of_exits(self, exits = {}):
        if self in exits:
            return exits, 0
        else:
            return exits | {self:None}, 1

    def has_exit(self, exit):
        return self is exit

    def extract(self, exit):
        if self.has_exit(exit):
            return exit
        else:
            return None

    def reduce(self):
        return self

    def dealias(new_value, new_values, new_exits):
        new_values = {} if new_values is None else new_values
        new_exits = {} if new_exits is None else new_exits
        if new_value in new_values:
            new_exit = new_values[new_value]
            assert new_exit in new_exits
        else:
            new_exit = ROABVDD_Exit.new()
            assert new_exit not in new_exits, f"exit {new_exit} for value {new_value} already defined in {new_exits}"
            new_values |= {new_value:new_exit}
            new_exits |= {new_exit:new_value}
        return new_values, new_exits, new_exit

    def compute_unary(self, sid_line, op, old_exits, new_values = None, new_exits = None):
        new_value = op(old_exits[self])
        assert sid_line.is_unsigned_value(new_value)
        return ROABVDD_Exit.dealias(new_value, new_values, new_exits)

    def get_binary_exit(self, bvdd, inorder = True):
        if inorder:
            return self, bvdd
        else:
            return bvdd, self

    def apply_binary(self, bvdd, inorder = True):
        if isinstance(bvdd, ROABVDD_Exit):
            return self.get_binary_exit(bvdd, inorder)
        else:
            return bvdd.intersection(self, not inorder)

    def intersection(self, bvdd, inorder = True):
        return self.apply_binary(bvdd, inorder)

    def merge(self, bvdd, inorder = True):
        assert bvdd is None
        return self.get_binary_exit(None, inorder)

    def union(self, bvdd, inorder = True):
        return self.merge(bvdd, inorder)

    def exclude(self, bvdd):
        return self.get_binary_exit(bvdd)

    def exclusion(self, bvdd):
        return self.exclude(bvdd)

    def sample_input_values(self):
        return dict()

class ROABVDD_Node:
    bvdds = {}

    intersection_bvdds = {}
    intersection_hits = 0

    union_bvdds = {}
    union_hits = 0

    exclusion_bvdds = {}
    exclusion_hits = 0

    def __init__(self, var_line):
        self.var_line = var_line
        self.inputs = 0
        self.outputs = {}

    def get_input_values(inputs):
        input_value = 0
        input_values = []
        while inputs != 0:
            if inputs % 2 == 1:
                input_values += [input_value]
            inputs //= 2
            input_value += 1
        return input_values

    def __str__(self):
        string = ""
        for output in self.outputs:
            for input_value in ROABVDD_Node.get_input_values(self.outputs[output]):
                if string:
                    string += ",\n"
                string += f"{input_value}"
                if isinstance(output, ROABVDD_Exit):
                    string += f" -> {output}"
                else:
                    assert isinstance(output, ROABVDD_Node)
                    string += f" & {output}"
        return f"{{{string}}}"

    def __hash__(self):
        return hash((self.var_line, self.inputs, tuple(self.outputs), tuple(self.outputs.values())))

    def __eq__(self, bvdd):
        return (isinstance(bvdd, ROABVDD_Node) and
            self.var_line is bvdd.var_line and
            self.inputs == bvdd.inputs and
            self.outputs == bvdd.outputs)

    def number_of_inputs(self):
        n = 0
        for output in self.outputs:
            n += self.outputs[output].bit_count()
            n += output.number_of_inputs()
        return n

    def number_of_exits(self, exits = {}):
        n = 0
        for output in self.outputs:
            exits, m = output.number_of_exits(exits)
            n += m
        return exits, n

    def set_input(self, inputs, output):
        assert 0 < inputs < 2**2**self.var_line.sid_line.size
        assert not (inputs & self.inputs)
        if output is not None:
            self.inputs |= inputs
            if output not in self.outputs:
                self.outputs[output] = inputs
            else:
                assert not (inputs & self.outputs[output])
                self.outputs[output] |= inputs
        return self

    def has_exit(self, exit):
        for output in self.outputs:
            if output.has_exit(exit):
                return True
        return False

    def extract(self, exit):
        bvdd = ROABVDD_Node(self.var_line)
        for output in self.outputs:
            bvdd.set_input(self.outputs[output], output.extract(exit))
        return bvdd.reduce()

    def reduce(self, sort = True):
        if not self.inputs:
            return None
        elif len(self.outputs) == 1:
            # outputs are all isomorphic
            if next(iter(self.outputs.values())) == 2**2**self.var_line.sid_line.size - 1:
                # remove nodes that have all outputs and all outputs are isomorphic
                return next(iter(self.outputs.keys()))
        elif sort:
            # sort outputs by inputs to obtain canonical ROABVDDs
            self.outputs = dict(sorted(self.outputs.items(), key=lambda x: x[1]))
        # assert: outputs are all isomorphic due to hashing equivalent objects to the same hash
        if self not in ROABVDD_Node.bvdds:
            ROABVDD_Node.bvdds[self] = self
        return ROABVDD_Node.bvdds[self]

    def compute_unary(self, sid_line, op, old_exits, new_values = None, new_exits = None):
        unary_bvdd = ROABVDD_Node(self.var_line)
        for output in self.outputs:
            new_values, new_exits, new_bvdd = output.compute_unary(sid_line, op,
                old_exits, new_values, new_exits)
            unary_bvdd.set_input(self.outputs[output], new_bvdd)
        # assert outputs of unary_bvdd are sorted
        return new_values, new_exits, unary_bvdd.reduce(False)

    def compute_binary(bvdd, sid_line, op, left_exits, right_exits, new_values = None, new_exits = None):
        if isinstance(bvdd, tuple):
            if op is None:
                if bvdd[1] is None or right_exits is None:
                    # ignore right exit of constrain, merge, and exclude
                    new_value = left_exits[bvdd[0]]
                else:
                    assert bvdd[0] is None
                    # ignore left exit of merge
                    new_value = right_exits[bvdd[1]]
            else:
                new_value = op(left_exits[bvdd[0]], right_exits[bvdd[1]])
                assert sid_line.is_unsigned_value(new_value)
            return ROABVDD_Exit.dealias(new_value, new_values, new_exits)
        else:
            assert isinstance(bvdd, ROABVDD_Node)
            binary_bvdd = ROABVDD_Node(bvdd.var_line)
            for output in bvdd.outputs:
                new_values, new_exits, new_bvdd = ROABVDD_Node.compute_binary(output, sid_line, op,
                    left_exits, right_exits, new_values, new_exits)
                binary_bvdd.set_input(bvdd.outputs[output], new_bvdd)
            # assert outputs of binary_bvdd are sorted
            return new_values, new_exits, binary_bvdd.reduce(False)

    def apply_binary(self, bvdd, inorder = True):
        if isinstance(bvdd, ROABVDD_Exit):
            binary_bvdd = ROABVDD_Node(self.var_line)
            for output in self.outputs:
                binary_bvdd.set_input(self.outputs[output],
                    output.intersection(bvdd, inorder))
        else:
            assert isinstance(bvdd, ROABVDD_Node)
            if self.var_line > bvdd.var_line:
                binary_bvdd = ROABVDD_Node(bvdd.var_line)
                for output in bvdd.outputs:
                    binary_bvdd.set_input(bvdd.outputs[output],
                        self.intersection(output))
            else:
                binary_bvdd = ROABVDD_Node(self.var_line)
                if self.var_line < bvdd.var_line:
                    for output in self.outputs:
                        binary_bvdd.set_input(self.outputs[output],
                            output.intersection(bvdd))
                else:
                    assert self.var_line is bvdd.var_line
                    for output1 in self.outputs:
                        inputs1 = self.outputs[output1] & bvdd.inputs
                        if inputs1:
                            for output2 in bvdd.outputs:
                                inputs2 = inputs1 & bvdd.outputs[output2]
                                if inputs2:
                                    binary_bvdd.set_input(inputs2,
                                        output1.intersection(output2))
                                    inputs1 &= ~bvdd.outputs[output2]
        return binary_bvdd.reduce()

    def intersection(self, bvdd, inorder = True):
        if inorder and (self, bvdd) in ROABVDD_Node.intersection_bvdds:
            ROABVDD_Node.intersection_hits += 1
            return ROABVDD_Node.intersection_bvdds[(self, bvdd)]
        elif not inorder and (bvdd, self) in ROABVDD_Node.intersection_bvdds:
            ROABVDD_Node.intersection_hits += 1
            return ROABVDD_Node.intersection_bvdds[(bvdd, self)]
        else:
            binary_bvdd = self.apply_binary(bvdd, inorder)
            if inorder:
                assert (self, bvdd) not in ROABVDD_Node.intersection_bvdds
                ROABVDD_Node.intersection_bvdds[(self, bvdd)] = binary_bvdd
            else:
                assert (bvdd, self) not in ROABVDD_Node.intersection_bvdds
                ROABVDD_Node.intersection_bvdds[(bvdd, self)] = binary_bvdd
            return binary_bvdd

    def merge(self, bvdd, inorder = True):
        if bvdd is None:
            merge_bvdd = ROABVDD_Node(self.var_line)
            for output in self.outputs:
                merge_bvdd.set_input(self.outputs[output], output.union(None, inorder))
        else:
            assert isinstance(bvdd, ROABVDD_Node)
            if self.var_line > bvdd.var_line:
                return bvdd.union(self, not inorder)
            else:
                merge_bvdd = ROABVDD_Node(self.var_line)
                if self.var_line < bvdd.var_line:
                    for output in self.outputs:
                        # assert: intersection of self and bvdd is empty
                        assert isinstance(output, ROABVDD_Node)
                        merge_bvdd.set_input(self.outputs[output],
                            output.union(bvdd, inorder))
                    if self.inputs < 2**2**self.var_line.sid_line.size - 1:
                        inputs = 2**2**self.var_line.sid_line.size - 1 - self.inputs
                        merge_bvdd.set_input(inputs, bvdd.union(None, not inorder))
                else:
                    assert self.var_line is bvdd.var_line
                    for output1 in self.outputs:
                        inputs1 = self.outputs[output1]
                        if inputs1 & bvdd.inputs:
                            for output2 in bvdd.outputs:
                                inputs2 = inputs1 & bvdd.outputs[output2]
                                if inputs2:
                                    # assert: intersection of self and bvdd is empty
                                    assert isinstance(output1, ROABVDD_Node)
                                    assert isinstance(output2, ROABVDD_Node)
                                    merge_bvdd.set_input(inputs2,
                                        output1.union(output2, inorder))
                                    inputs1 &= ~bvdd.outputs[output2]
                        if inputs1:
                            merge_bvdd.set_input(inputs1, output1.union(None, inorder))
                    for output2 in bvdd.outputs:
                        inputs2 = bvdd.outputs[output2] & ~self.inputs
                        if inputs2:
                            merge_bvdd.set_input(inputs2, output2.union(None, not inorder))
        return merge_bvdd.reduce()

    def union(self, bvdd, inorder = True):
        if inorder and (self, bvdd) in ROABVDD_Node.union_bvdds:
            ROABVDD_Node.union_hits += 1
            return ROABVDD_Node.union_bvdds[(self, bvdd)]
        elif not inorder and (bvdd, self) in ROABVDD_Node.union_bvdds:
            ROABVDD_Node.union_hits += 1
            return ROABVDD_Node.union_bvdds[(bvdd, self)]
        else:
            merge_bvdd = self.merge(bvdd, inorder)
            if inorder:
                assert (self, bvdd) not in ROABVDD_Node.union_bvdds
                ROABVDD_Node.union_bvdds[(self, bvdd)] = merge_bvdd
            else:
                assert (bvdd, self) not in ROABVDD_Node.union_bvdds
                ROABVDD_Node.union_bvdds[(bvdd, self)] = merge_bvdd
            return merge_bvdd

    def exclude(self, bvdd):
        if isinstance(bvdd, ROABVDD_Exit):
            return None
        else:
            if bvdd is None:
                exclude_bvdd = ROABVDD_Node(self.var_line)
                for output in self.outputs:
                    exclude_bvdd.set_input(self.outputs[output], output.exclusion(None))
            else:
                assert isinstance(bvdd, ROABVDD_Node), f"expected ROABVDD_Node, got {type(bvdd)}"
                if self.var_line > bvdd.var_line:
                    exclude_bvdd = ROABVDD_Node(bvdd.var_line)
                    for output in bvdd.outputs:
                        exclude_bvdd.set_input(bvdd.outputs[output],
                            self.exclusion(output))
                else:
                    exclude_bvdd = ROABVDD_Node(self.var_line)
                    if self.var_line < bvdd.var_line:
                        for output in self.outputs:
                            exclude_bvdd.set_input(self.outputs[output],
                                output.exclusion(bvdd))
                    else:
                        assert self.var_line is bvdd.var_line
                        for output1 in self.outputs:
                            inputs1 = self.outputs[output1]
                            if inputs1 & bvdd.inputs:
                                for output2 in bvdd.outputs:
                                    inputs2 = inputs1 & bvdd.outputs[output2]
                                    if inputs2:
                                        exclude_bvdd.set_input(inputs2,
                                            output1.exclusion(output2))
                                        inputs1 &= ~bvdd.outputs[output2]
                            if inputs1:
                                exclude_bvdd.set_input(inputs1, output1.exclusion(None))
            return exclude_bvdd.reduce()

    def exclusion(self, bvdd):
        if (self, bvdd) in ROABVDD_Node.exclusion_bvdds:
            ROABVDD_Node.exclusion_hits += 1
            return ROABVDD_Node.exclusion_bvdds[(self, bvdd)]
        else:
            exclude_bvdd = self.exclude(bvdd)
            assert (self, bvdd) not in ROABVDD_Node.exclusion_bvdds
            ROABVDD_Node.exclusion_bvdds[(self, bvdd)] = exclude_bvdd
            return exclude_bvdd

    def sample_input_values(self):
        # Grab an arbitrary branch to walk down to
        outp, inp = next(self.outputs.items())

        vals = outp.sample_input_values()
        vals[self.var_line] = next(ROABVDD_Node.get_input_values(inp))
        return vals

class ROABVDD:
    # a reduced ordered algebraic bitvector decision diagram (ROABVDD) is
    # an algebraic decision diagram (ADD) over bitvectors rather than bits

    # given an n-bit bitvector, we use 2**n-bit unsigned integers
    # to represent sets of n-bit bitvector constants that in turn
    # represent branches in ROABVDDs:
    # Theta(2**n)-time set intersection and union with
    # O(2**n/n) and Omega(n*(2**n-1)/2**n) spatial overhead

    def __init__(self, values, exits, bvdd):
        assert isinstance(values, dict)
        assert isinstance(exits, dict)
        assert isinstance(bvdd, ROABVDD_Exit) or isinstance(bvdd, ROABVDD_Node)
        self.values = values
        self.exits = exits
        self.bvdd = bvdd
        ROABVDD_Exit.bump = 0 # exits only need to be unique within ROABVDDs

    def __str__(self):
        return f"{self.values} {self.exits} {self.bvdd}"

    def utilization(hits, misses):
        if hits + misses == 0:
            return "0.0%"
        else:
            return f"{round(hits / (hits + misses) * 100, 2)}% ({hits} hits, {misses} misses)"

    def print_profile():
        print(f"Exit cache utilization: {ROABVDD.utilization(ROABVDD_Exit.exit_hits, len(ROABVDD_Exit.exits))}")
        print(f"Node intersection cache utilization: {ROABVDD.utilization(ROABVDD_Node.intersection_hits, len(ROABVDD_Node.intersection_bvdds))}")
        print(f"Node union cache utilization: {ROABVDD.utilization(ROABVDD_Node.union_hits, len(ROABVDD_Node.union_bvdds))}")
        print(f"Node exclusion cache utilization: {ROABVDD.utilization(ROABVDD_Node.exclusion_hits, len(ROABVDD_Node.exclusion_bvdds))}")

    def number_of_inputs(self):
        return self.bvdd.number_of_inputs()

    def number_of_values(self):
        return len(self.values)

    def is_consistent(self):
        assert self.number_of_values() == len(self.exits)
        assert self.number_of_values() == self.bvdd.number_of_exits()[1]
        for value in self.values:
            assert self.values[value] in self.exits
            assert self.exits[self.values[value]] == value
            assert self.bvdd.has_exit(self.values[value])
        return True

    def is_never_false(self):
        return self.number_of_values() == 1 and True in self.values

    def is_never_true(self):
        return self.number_of_values() == 1 and False in self.values

    def constant(value):
        assert isinstance(value, bool) or isinstance(value, int)
        exit = ROABVDD_Exit.new()
        return ROABVDD({value:exit}, {exit:value}, exit)

    def projection(variable):
        assert isinstance(variable, Variable)
        bvdd = ROABVDD_Node(variable)
        if isinstance(variable.sid_line, Bool):
            false_exit = ROABVDD_Exit.new()
            true_exit = ROABVDD_Exit.new()
            values = {False:false_exit, True:true_exit}
            exits = {false_exit:False, true_exit:True}
            bvdd.set_input(2**0, false_exit)
            bvdd.set_input(2**1, true_exit)
        else:
            values = {}
            exits = {}
            for value in range(2**variable.sid_line.size):
                value_exit = ROABVDD_Exit.new()
                values |= {value:value_exit}
                exits |= {value_exit:value}
                bvdd.set_input(2**value, value_exit)
        return ROABVDD(values, exits, bvdd)

    def compute_unary(self, sid_line, op):
        return ROABVDD(*self.bvdd.compute_unary(sid_line, op, self.exits))

    def compute_binary(self, sid_line, op, roabvdd):
        assert isinstance(roabvdd, ROABVDD)
        new_bvdd = self.bvdd.intersection(roabvdd.bvdd)
        if new_bvdd is None:
            # TODO: check whether reachable
            return None
        return ROABVDD(*ROABVDD_Node.compute_binary(new_bvdd, sid_line, op, self.exits, roabvdd.exits))

    def constrain(self, sid_line, constraint):
        assert isinstance(constraint.bvdd, ROABVDD_Exit) or isinstance(constraint.bvdd, ROABVDD_Node)
        new_bvdd = self.bvdd.intersection(constraint.bvdd)
        if new_bvdd is None:
            # TODO: check whether reachable
            return None
        return ROABVDD(*ROABVDD_Node.compute_binary(new_bvdd, sid_line, None, self.exits, None))

    def merge(self, sid_line, roabvdd):
        assert isinstance(self.bvdd, ROABVDD_Node) and isinstance(roabvdd.bvdd, ROABVDD_Node)
        new_bvdd = self.bvdd.union(roabvdd.bvdd)
        assert new_bvdd is not None
        return ROABVDD(*ROABVDD_Node.compute_binary(new_bvdd, sid_line, None, self.exits, roabvdd.exits))

    def exclude(self, sid_line, constraint):
        if constraint.is_never_false():
            return self
        else:
            new_bvdd = self.bvdd.exclusion(constraint.bvdd)
            assert new_bvdd is not None
            return ROABVDD(*ROABVDD_Node.compute_binary(new_bvdd, sid_line, None, self.exits, None))

    def get_false_constraint(self):
        if False in self.values:
            if True in self.values:
                new_bvdd = self.bvdd.extract(self.values[False])
                return ROABVDD({False:self.values[False]}, {self.values[False]:False}, new_bvdd)
            else:
                return self
        else:
            return None

    def get_true_constraint(self):
        if True in self.values:
            if False in self.values:
                new_bvdd = self.bvdd.extract(self.values[True])
                return ROABVDD({True:self.values[True]}, {self.values[True]:True}, new_bvdd)
            else:
                return self
        else:
            return None

class BV_Grouping:
    # generalizing CFLOBDDs to bitvector input variables with up to 8 bits
    pair_product_cache = {}
    pair_product_cache_hits = 0

    triple_product_cache = {}
    triple_product_cache_hits = 0

    reduction_cache = {}
    reduction_cache_hits = 0

    def __init__(self, level, number_of_input_bits, number_of_exits = 1):
        assert level >= 0
        self.level = level
        assert 0 < number_of_input_bits <= 8
        self.number_of_input_bits = number_of_input_bits
        self.number_of_exits = number_of_exits

    def __repr__(self):
        return f"{self.level} w/ {self.number_of_input_bits} input bits & {self.number_of_exits} exits"

    def number_of_paths(self):
        return sum(self.number_of_paths_per_exit.values())

    def number_of_inputs(self):
        return sum(self.number_of_inputs_per_exit.values())

    def is_consistent(self):
        assert self.number_of_exits > 0
        return True

    def is_pair_product_cached(self, g2):
        if (self, g2) in BV_Grouping.pair_product_cache:
            BV_Grouping.pair_product_cache_hits += 1
            return True
        else:
            return False

    def get_cached_pair_product(self, g2):
        assert self.is_pair_product_cached(g2)
        return BV_Grouping.pair_product_cache[(self, g2)]

    def cache_pair_product(self, g2, pair_product, pt_ans):
        if (self, g2) not in BV_Grouping.pair_product_cache:
            BV_Grouping.pair_product_cache[(self, g2)] = (pair_product, pt_ans)
        return BV_Grouping.pair_product_cache[(self, g2)]

    def is_triple_product_cached(self, g2, g3):
        if (self, g2, g3) in BV_Grouping.triple_product_cache:
            BV_Grouping.triple_product_cache_hits += 1
            return True
        else:
            return False

    def get_cached_triple_product(self, g2, g3):
        assert self.is_triple_product_cached(g2, g3)
        return BV_Grouping.triple_product_cache[(self, g2, g3)]

    def cache_triple_product(self, g2, g3, triple_product, pt_ans):
        if (self, g2, g3) not in BV_Grouping.triple_product_cache:
            BV_Grouping.triple_product_cache[(self, g2, g3)] = (triple_product, pt_ans)
        return BV_Grouping.triple_product_cache[(self, g2, g3)]

    def reduction_hash(reduction_tuple):
        return hash(tuple(reduction_tuple.values()))

    def is_reduction_cached(self, reduction_tuple):
        if (self, BV_Grouping.reduction_hash(reduction_tuple)) in BV_Grouping.reduction_cache:
            BV_Grouping.reduction_cache_hits += 1
            return True
        else:
            return False

    def get_cached_reduction(self, reduction_tuple):
        assert self.is_reduction_cached(reduction_tuple)
        return BV_Grouping.reduction_cache[(self, BV_Grouping.reduction_hash(reduction_tuple))]

    def cache_reduction(self, reduction_tuple, reduction):
        reduction_hash = BV_Grouping.reduction_hash(reduction_tuple)
        if (self, reduction_hash) not in BV_Grouping.reduction_cache:
            BV_Grouping.reduction_cache[(self, reduction_hash)] = reduction
        return BV_Grouping.reduction_cache[(self, reduction_hash)]

    def is_no_distinction_proto(self):
        return isinstance(self, BV_Dont_Care_Grouping) or isinstance(self, BV_No_Distinction_Proto)

    def reduce(self, reduction_tuple):
        assert len(reduction_tuple) == self.number_of_exits

        if reduction_tuple == dict(enumerate(range(1, len(reduction_tuple) + 1), 1)):
            return 1, self
        else:
            reduction_length = len(set(reduction_tuple.values()))
            if reduction_length == 1:
                return 1, BV_No_Distinction_Proto.representative(self.level,
                    self.number_of_input_bits)
            return reduction_length, self

class BV_Dont_Care_Grouping(BV_Grouping):
    representatives = {}

    def __init__(self, number_of_input_bits):
        super().__init__(0, number_of_input_bits)
        self.number_of_paths_per_exit = {1:2**number_of_input_bits}
        self.number_of_inputs_per_exit = {1:1}

    def __repr__(self):
        return "dontcare @ " + super().__repr__()

    def get_paths(self, exit_i, index_i = 0):
        assert exit_i == 1
        return [(index_i, 0)]

    def is_consistent(self):
        assert super().is_consistent()
        return True

    def representative(number_of_input_bits):
        if number_of_input_bits not in BV_Dont_Care_Grouping.representatives:
            BV_Dont_Care_Grouping.representatives[number_of_input_bits] = BV_Dont_Care_Grouping(number_of_input_bits)
            assert BV_Dont_Care_Grouping.representatives[number_of_input_bits].is_consistent()
        return BV_Dont_Care_Grouping.representatives[number_of_input_bits]

    def pair_product(self, g2, inorder = True):
        assert isinstance(g2, BV_Grouping)

        if inorder:
            g1 = self
        else:
            g1 = g2
            g2 = self

        if g1.is_pair_product_cached(g2):
            return g1.get_cached_pair_product(g2)

        assert g1.number_of_input_bits == g2.number_of_input_bits

        if inorder:
            return g1.cache_pair_product(g2,
                g2, dict([(k, (1, k)) for k in range(1, g2.number_of_exits + 1)]))
        else:
            return g1.cache_pair_product(g2,
                g1, dict([(k, (k, 1)) for k in range(1, g1.number_of_exits + 1)]))

    def triple_product(self, g2, g3, order = 1):
        assert isinstance(g2, BV_Grouping) or isinstance(g3, BV_Grouping)

        if order == 1:
            g1 = self
        elif order == 2:
            g1 = g2
            g2 = self
        else:
            assert order == 3
            g1 = g2
            g2 = g3
            g3 = self

        if g1.is_triple_product_cached(g2, g3):
            return g1.get_cached_triple_product(g2, g3)

        assert g1.number_of_input_bits == g2.number_of_input_bits == g3.number_of_input_bits

        if g1.is_no_distinction_proto() and g2.is_no_distinction_proto():
            return g1.cache_triple_product(g2, g3,
                g3, dict([(k, (1, 1, k)) for k in range(1, g3.number_of_exits + 1)]))
        elif g1.is_no_distinction_proto() and g3.is_no_distinction_proto():
            return g1.cache_triple_product(g2, g3,
                g2, dict([(k, (1, k, 1)) for k in range(1, g2.number_of_exits + 1)]))
        elif g2.is_no_distinction_proto() and g3.is_no_distinction_proto():
            return g1.cache_triple_product(g2, g3,
                g1, dict([(k, (k, 1, 1)) for k in range(1, g1.number_of_exits + 1)]))
        elif g1.is_no_distinction_proto():
            g, pt = g2.pair_product(g3)
            return g1.cache_triple_product(g2, g3,
                g, dict([(jk, (1, pt[jk][0], pt[jk][1])) for jk in pt]))
        elif g2.is_no_distinction_proto():
            g, pt = g1.pair_product(g3)
            return g1.cache_triple_product(g2, g3,
                g, dict([(jk, (pt[jk][0], 1, pt[jk][1])) for jk in pt]))
        else:
            assert g3.is_no_distinction_proto()
            g, pt = g1.pair_product(g2)
            return g1.cache_triple_product(g2, g3,
                g, dict([(jk, (pt[jk][0], pt[jk][1], 1)) for jk in pt]))

    def reduce(self, reduction_tuple):
        assert reduction_tuple == {1:1}
        return self

class BV_Fork_Grouping(BV_Grouping):
    representatives = {}
    representatives_hits = 0

    def __init__(self, inputs, number_of_input_bits):
        assert 0 < len(inputs) <= 2**number_of_input_bits
        super().__init__(0, number_of_input_bits, len(inputs))
        self.inputs = inputs
        self.number_of_paths_per_exit = dict([(i, inputs[i].bit_count()) for i in inputs])
        self.number_of_inputs_per_exit = self.number_of_paths_per_exit

    def __repr__(self):
        indentation = " " * (CFLOBVDD.max_level - self.level + 1)
        return (indentation + "\n" +
            indentation + "fork @ " + super().__repr__() + ":\n" +
            indentation + f"{self.inputs}")

    def __hash__(self):
        return hash((self.number_of_exits,
            self.number_of_input_bits,
            tuple(self.inputs.values())))

    def __eq__(self, g2):
        return (isinstance(g2, BV_Fork_Grouping) and
            self.number_of_exits == g2.number_of_exits and
            self.number_of_input_bits == g2.number_of_input_bits and
            self.inputs == g2.inputs)

    def get_input_values(inputs, input_value = 0):
        assert inputs >= 0
        if inputs == 0:
            return []
        elif inputs == 1:
            return [input_value]
        else:
            number_of_input_bits = math.ceil(math.log2(inputs.bit_length()))
            assert 0 < number_of_input_bits <= 8, f"number_of_input_bits {number_of_input_bits} out of range with {inputs}"

            mid_input = 2**(number_of_input_bits - 1)

            low_inputs = inputs % 2**mid_input
            low_values = BV_Fork_Grouping.get_input_values(low_inputs, input_value)

            high_inputs = inputs >> mid_input

            if low_inputs == high_inputs:
                return [low_value + mid_input for low_value in low_values] + low_values
            else:
                return BV_Fork_Grouping.get_input_values(high_inputs, input_value + mid_input) + low_values

    def get_paths(self, exit_i, index_i = 0):
        assert 1 <= exit_i <= self.number_of_exits
        return [(index_i, self.inputs[exit_i])]

    def lowest_input(inputs):
        assert inputs > 0
        return inputs & ~(inputs - 1)

    def highest_input(inputs):
        assert inputs > 0
        return 2**int(math.log2(inputs))

    def is_consistent(self):
        assert super().is_consistent()
        assert len(self.inputs) == self.number_of_exits
        previous_exit = 0
        previous_inputs = 0
        union = 0
        for exit in self.inputs:
            assert exit == previous_exit + 1
            previous_exit = exit
            current_inputs = self.inputs[exit]
            assert 0 < current_inputs < 2**2**self.number_of_input_bits - 1
            assert (exit == 1 or
                BV_Fork_Grouping.lowest_input(current_inputs) >
                    BV_Fork_Grouping.lowest_input(previous_inputs)), f"{exit} == 1 or {BV_Fork_Grouping.lowest_input(current_inputs)} > {BV_Fork_Grouping.lowest_input(previous_inputs)}"
            previous_inputs = current_inputs
            assert current_inputs & union == 0
            union |= current_inputs
        assert union == 2**2**self.number_of_input_bits - 1, f"{union} == {2**2**self.number_of_input_bits - 1}"
        return True

    def representative(self):
        if self in BV_Fork_Grouping.representatives:
            BV_Fork_Grouping.representatives_hits += 1
        else:
            assert self.is_consistent()
            BV_Fork_Grouping.representatives[self] = self
        return BV_Fork_Grouping.representatives[self]

    def projection_proto(number_of_input_bits):
        return BV_Fork_Grouping(dict([(i + 1, 2**i)
            for i in range(2**number_of_input_bits)]),
            number_of_input_bits).representative()

    def fork_if_non_empty(inputs, number_of_input_bits, pair_tuples):
        if inputs:
            return BV_Fork_Grouping(inputs, number_of_input_bits).representative(), pair_tuples
        else:
            return BV_Dont_Care_Grouping.representative(number_of_input_bits).pair_product(BV_Dont_Care_Grouping.representative(number_of_input_bits))

    def pair_product(self, g2):
        assert isinstance(g2, BV_Grouping)

        g1 = self

        assert g1.number_of_input_bits == g2.number_of_input_bits

        if isinstance(g2, BV_Dont_Care_Grouping):
            return g2.pair_product(g1, False)
        else:
            if g1.is_pair_product_cached(g2):
                return g1.get_cached_pair_product(g2)

            assert isinstance(g2, BV_Fork_Grouping)

            g_exit = 0
            g_inputs = {}
            g_pair_tuples = {}

            g2_exit = 1
            g2_inputs = {}
            g2_inputs[g2_exit] = g2.inputs[g2_exit]

            for g1_exit in g1.inputs:
                g1_inputs = g1.inputs[g1_exit]

                # exploit lexicographic ordering of g1 and g2 inputs by lowest input

                while (BV_Fork_Grouping.highest_input(g2_inputs[g2_exit]) <
                    BV_Fork_Grouping.lowest_input(g1_inputs)):
                    # move on to next g2 inputs
                    if g2_exit < g2.number_of_exits:
                        g2_exit += 1
                        if g2_exit not in g2_inputs:
                            g2_inputs[g2_exit] = g2.inputs[g2_exit]
                    else:
                        return g1.cache_pair_product(g2,
                            *BV_Fork_Grouping.fork_if_non_empty(g_inputs,
                                g1.number_of_input_bits,
                                g_pair_tuples))

                next_g2_exit = g2_exit

                while (g1_inputs > 0 and
                    BV_Fork_Grouping.lowest_input(g2_inputs[next_g2_exit]) <=
                        BV_Fork_Grouping.highest_input(g1_inputs)):
                    # intersect with all overlapping next g2 inputs
                    intersection = g1_inputs & g2_inputs[next_g2_exit]

                    if intersection != 0:
                        g_exit += 1

                        # insert intersection sorted by lowest input
                        # to establish lexicographical ordering of g inputs
                        exit_i = g_exit
                        while (exit_i > 1 and
                            BV_Fork_Grouping.lowest_input(intersection) <
                                BV_Fork_Grouping.lowest_input(g_inputs[exit_i - 1])):
                            g_inputs[exit_i] = g_inputs[exit_i - 1]
                            g_pair_tuples[exit_i] = g_pair_tuples[exit_i - 1]
                            exit_i -= 1
                        g_inputs[exit_i] = intersection
                        g_pair_tuples[exit_i] = (g1_exit, next_g2_exit)

                        g1_inputs &= ~intersection
                        # do not remove intersection from next g2 inputs
                        # to maintain lexicographical ordering of g2 inputs

                    next_g2_exit += 1

                    if next_g2_exit <= len(g2.inputs):
                        if next_g2_exit not in g2_inputs:
                            g2_inputs[next_g2_exit] = g2.inputs[next_g2_exit]
                    else:
                        break

            return g1.cache_pair_product(g2,
                *BV_Fork_Grouping.fork_if_non_empty(g_inputs,
                    g1.number_of_input_bits,
                    g_pair_tuples))

    def triple_product(self, g2, g3):
        assert isinstance(g2, BV_Grouping) and isinstance(g3, BV_Grouping)

        g1 = self

        assert g1.number_of_input_bits == g2.number_of_input_bits == g3.number_of_input_bits

        if g2.is_no_distinction_proto():
            return g2.triple_product(g1, g3, 2)
        elif g3.is_no_distinction_proto():
            return g3.triple_product(g1, g2, 3)
        else:
            if g1.is_triple_product_cached(g2, g3):
                return g1.get_cached_triple_product(g2, g3)

            assert isinstance(g2, BV_Fork_Grouping) and isinstance(g3, BV_Fork_Grouping)

            g, pt23 = g2.pair_product(g3)
            g, pt123 = g1.pair_product(g)

            tt = dict([(k, (pt123[k][0], pt23[pt123[k][1]][0], pt23[pt123[k][1]][1]))
                for k in pt123])

            return g1.cache_triple_product(g2, g3, g, tt)

    def reduce(self, reduction_tuple):
        reduction_length, reduction = super().reduce(reduction_tuple)

        if reduction_length == 1:
            return reduction
        else:
            if self.is_reduction_cached(reduction_tuple):
                return self.get_cached_reduction(reduction_tuple)

            g_exits = {}
            g_inputs = {}

            for exit in self.inputs:
                reduced_to_exit = reduction_tuple[exit]

                assert reduced_to_exit <= exit

                if reduced_to_exit not in g_exits:
                    new_exit = len(g_inputs) + 1
                    g_exits[reduced_to_exit] = new_exit
                    g_inputs[new_exit] = self.inputs[exit]
                else:
                    new_exit = g_exits[reduced_to_exit]

                    assert g_inputs[new_exit] & self.inputs[exit] == 0

                    g_inputs[new_exit] |= self.inputs[exit]

            return self.cache_reduction(reduction_tuple,
                BV_Fork_Grouping(g_inputs, self.number_of_input_bits).representative())

class BV_Internal_Grouping(BV_Grouping):
    representatives = {}
    representatives_hits = 0

    def __init__(self, level, number_of_input_bits, number_of_exits = 1):
        assert level > 0
        super().__init__(level, number_of_input_bits, number_of_exits)
        self.a_connection = None
        self.a_return_tuple = {}
        self.number_of_b_connections = 0
        self.b_connections = {}
        self.b_return_tuples = {}
        self.number_of_paths_per_exit = {}
        self.number_of_inputs_per_exit = {}

    def __repr__(self):
        indentation = " " * (CFLOBVDD.max_level - self.level + 1)
        return (indentation + "\n" +
            indentation + f"{type(self).__name__} @ " + super().__repr__() + ":\n" +
            indentation + f"a_c: {self.a_connection}\n" +
            indentation + f"a_rt: {self.a_return_tuple}\n" +
            indentation + f"n_of_b: {self.number_of_b_connections}\n" +
            indentation + f"b_c: {self.b_connections}\n" +
            indentation + f"b_rt: {self.b_return_tuples}")

    def __hash__(self):
        return hash((self.level,
            self.number_of_input_bits,
            self.number_of_exits,
            self.a_connection,
            tuple(self.a_return_tuple.values()),
            self.number_of_b_connections,
            tuple(self.b_connections.values()),
            tuple([(tuple(rt), tuple(rt.values())) for rt in self.b_return_tuples.values()])))

    def __eq__(self, g2):
        return (isinstance(g2, BV_Internal_Grouping) and
            self.level == g2.level and
            self.number_of_input_bits == g2.number_of_input_bits and
            self.number_of_exits == g2.number_of_exits and
            self.a_connection == g2.a_connection and
            self.a_return_tuple == g2.a_return_tuple and
            self.number_of_b_connections == g2.number_of_b_connections and
            self.b_connections == g2.b_connections and
            self.b_return_tuples == g2.b_return_tuples)

    def get_paths(self, exit_i, index_i = 0):
        inputs = []
        for b_i in self.b_return_tuples:
            b_rt = self.b_return_tuples[b_i]
            for b_e_i in b_rt:
                if exit_i == b_rt[b_e_i]:
                    inputs += [(self.a_connection.get_paths(b_i, index_i),
                        self.b_connections[b_i].get_paths(b_e_i,
                            index_i + 2**(self.level - 1)))]
                    break
        return inputs

    def is_consistent(self):
        assert super().is_consistent()
        g_a = self.a_connection
        assert isinstance(g_a, BV_Grouping)
        assert len(self.a_return_tuple) == g_a.number_of_exits
        assert len(self.a_return_tuple) == len(set(self.a_return_tuple.values()))
        assert self.number_of_b_connections == len(self.a_return_tuple)
        assert len(self.b_connections) == self.number_of_b_connections
        assert len(self.b_return_tuples) == len(self.b_connections)
        for g_a_e_i in self.a_return_tuple:
            assert 1 <= g_a_e_i <= g_a.number_of_exits
            a_e_i = self.a_return_tuple[g_a_e_i]
            assert g_a_e_i == a_e_i
            assert 1 <= a_e_i <= self.number_of_b_connections
        g_exits = {}
        for g_b_i in self.b_connections:
            g_b = self.b_connections[g_b_i]
            assert g_b_i in self.b_return_tuples
            g_b_i_rt = self.b_return_tuples[g_b_i]
            assert len(g_b_i_rt) == len(set(g_b_i_rt.values()))
            g_b_i_rt_targets = {}
            previous_target = 0
            for g_b_i_rt_e_j in g_b_i_rt:
                assert 1 <= g_b_i_rt_e_j <= g_b.number_of_exits, f"1 <= {g_b_i_rt_e_j} <= {g_b.number_of_exits}: {self}"
                g_b_i_rt_e_j_e_t = g_b_i_rt[g_b_i_rt_e_j]
                assert 1 <= g_b_i_rt_e_j_e_t <= self.number_of_exits
                assert g_b_i_rt_e_j_e_t not in g_b_i_rt_targets
                g_b_i_rt_targets[g_b_i_rt_e_j_e_t] = None
                if g_b_i_rt_e_j_e_t not in g_exits:
                    if previous_target != 0:
                        assert g_b_i_rt_e_j_e_t == previous_target + 1
                    previous_target = g_b_i_rt_e_j_e_t
            g_exits |= g_b_i_rt_targets
        return True

    def pre_compute_number_of_paths_and_inputs_per_exit(self):
        self.number_of_paths_per_exit = dict([(i, 0) for i in range(1, self.number_of_exits + 1)])
        self.number_of_inputs_per_exit = dict([(i, 0) for i in range(1, self.number_of_exits + 1)])
        g_a = self.a_connection
        for g_b_i in self.b_connections:
            a_number_of_paths = g_a.number_of_paths_per_exit[g_b_i]
            a_number_of_inputs = g_a.number_of_inputs_per_exit[g_b_i]
            g_b = self.b_connections[g_b_i]
            g_b_i_rt = self.b_return_tuples[g_b_i]
            for g_b_i_rt_e_j in g_b_i_rt:
                e_i = g_b_i_rt[g_b_i_rt_e_j]
                b_number_of_paths = g_b.number_of_paths_per_exit[g_b_i_rt_e_j]
                b_number_of_inputs = g_b.number_of_inputs_per_exit[g_b_i_rt_e_j]
                self.number_of_paths_per_exit[e_i] += a_number_of_paths * b_number_of_paths
                self.number_of_inputs_per_exit[e_i] += a_number_of_inputs * b_number_of_inputs
        assert self.number_of_paths() >= self.number_of_inputs() >= self.number_of_exits

    def representative(self):
        self.pre_compute_number_of_paths_and_inputs_per_exit()
        if self in BV_Internal_Grouping.representatives:
            BV_Internal_Grouping.representatives_hits += 1
        else:
            assert self.is_consistent()
            BV_Internal_Grouping.representatives[self] = self
        return BV_Internal_Grouping.representatives[self]

    def projection_proto(level, input_i, number_of_input_bits, number_of_output_bits):
        # generalizing CFLOBDD projection to bitvectors of size >= 1
        if level == 0:
            assert input_i == 0 and number_of_output_bits == number_of_input_bits
            return BV_Fork_Grouping.projection_proto(number_of_input_bits)
        else:
            assert 0 <= input_i < 2**level
            assert number_of_output_bits % number_of_input_bits == 0
            assert 0 < number_of_output_bits <= (2**level - input_i) * number_of_input_bits

            g = BV_Internal_Grouping(level, number_of_input_bits, 2**number_of_output_bits)

            if input_i < 2**(level - 1):
                a_number_of_output_bits = min((2**(level - 1) - input_i) * number_of_input_bits,
                    number_of_output_bits)
                g.a_connection = BV_Internal_Grouping.projection_proto(level - 1,
                    input_i, number_of_input_bits, a_number_of_output_bits)
                g.a_return_tuple = dict([(e, e)
                    for e in range(1, 2**a_number_of_output_bits + 1)])

                input_i = 2**(level - 1)
            else:
                a_number_of_output_bits = 0

                g.a_connection = BV_No_Distinction_Proto.representative(level - 1,
                    number_of_input_bits)
                g.a_return_tuple[1] = 1

            g.number_of_b_connections = 2**a_number_of_output_bits

            b_number_of_output_bits = number_of_output_bits - a_number_of_output_bits

            if b_number_of_output_bits == 0:
                projection_proto = BV_No_Distinction_Proto.representative(level - 1,
                    number_of_input_bits)
            else:
                projection_proto = BV_Internal_Grouping.projection_proto(level - 1,
                    input_i - 2**(level - 1),
                    number_of_input_bits,
                    b_number_of_output_bits)

            g.b_connections = dict([(c, projection_proto)
                for c in range(1, g.number_of_b_connections + 1)])
            g.b_return_tuples = dict([(c,
                dict([(e, 2**b_number_of_output_bits * (c - 1) + e)
                    for e in range(1, 2**b_number_of_output_bits + 1)]))
                for c in range(1, g.number_of_b_connections + 1)])

            return g.representative()

    def pair_product(self, g2):
        assert isinstance(g2, BV_Grouping)

        g1 = self

        assert g1.level == g2.level
        assert g1.number_of_input_bits == g2.number_of_input_bits

        if g2.is_no_distinction_proto():
            return g2.pair_product(g1, False)
        else:
            if g1.is_pair_product_cached(g2):
                return g1.get_cached_pair_product(g2)

            assert isinstance(g2, BV_Internal_Grouping)

            g_a, pt_a = g1.a_connection.pair_product(g2.a_connection)

            g = BV_Internal_Grouping(g1.level, g1.number_of_input_bits, 0)

            g.a_connection = g_a
            g.a_return_tuple = dict([(i, i) for i in pt_a])

            g.number_of_b_connections = len(pt_a)

            pt_ans = {}
            pt_ans_inv = {}

            for j in pt_a:
                g_b, pt_b = g1.b_connections[pt_a[j][0]].pair_product(g2.b_connections[pt_a[j][1]])

                g.b_connections[j] = g_b
                g.b_return_tuples[j] = {}

                for i in pt_b:
                    c1 = g1.b_return_tuples[pt_a[j][0]][pt_b[i][0]]
                    c2 = g2.b_return_tuples[pt_a[j][1]][pt_b[i][1]]

                    if (c1, c2) in pt_ans_inv:
                        g.b_return_tuples[j][len(g.b_return_tuples[j]) + 1] = pt_ans_inv[(c1, c2)]
                    else:
                        g.number_of_exits += 1
                        g.b_return_tuples[j][len(g.b_return_tuples[j]) + 1] = g.number_of_exits
                        pt_ans[len(pt_ans) + 1] = (c1, c2)
                        pt_ans_inv[(c1, c2)] = len(pt_ans)

            return g1.cache_pair_product(g2, g.representative(), pt_ans)

    def triple_product(self, g2, g3):
        assert isinstance(g2, BV_Grouping) and isinstance(g3, BV_Grouping)

        g1 = self

        assert g1.level == g2.level == g3.level
        assert g1.number_of_input_bits == g2.number_of_input_bits == g3.number_of_input_bits

        if g2.is_no_distinction_proto():
            return g2.triple_product(g1, g3, 2)
        elif g3.is_no_distinction_proto():
            return g3.triple_product(g1, g2, 3)
        else:
            if g1.is_triple_product_cached(g2, g3):
                return g1.get_cached_triple_product(g2, g3)

            assert isinstance(g2, BV_Internal_Grouping) and isinstance(g3, BV_Internal_Grouping)

            g_a, tt_a = g1.a_connection.triple_product(g2.a_connection, g3.a_connection)

            g = BV_Internal_Grouping(g1.level, g1.number_of_input_bits, 0)

            g.a_connection = g_a
            g.a_return_tuple = dict([(i, i) for i in tt_a])

            g.number_of_b_connections = len(tt_a)

            pt_ans = {}
            pt_ans_inv = {}

            for j in tt_a:
                g_b, pt_b = g1.b_connections[tt_a[j][0]].triple_product(g2.b_connections[tt_a[j][1]],
                    g3.b_connections[tt_a[j][2]])

                g.b_connections[j] = g_b
                g.b_return_tuples[j] = {}

                for i in pt_b:
                    c1 = g1.b_return_tuples[tt_a[j][0]][pt_b[i][0]]
                    c2 = g2.b_return_tuples[tt_a[j][1]][pt_b[i][1]]
                    c3 = g3.b_return_tuples[tt_a[j][2]][pt_b[i][2]]

                    if (c1, c2, c3) in pt_ans_inv:
                        g.b_return_tuples[j][len(g.b_return_tuples[j]) + 1] = pt_ans_inv[(c1, c2, c3)]
                    else:
                        g.number_of_exits += 1
                        g.b_return_tuples[j][len(g.b_return_tuples[j]) + 1] = g.number_of_exits
                        pt_ans[len(pt_ans) + 1] = (c1, c2, c3)
                        pt_ans_inv[(c1, c2, c3)] = len(pt_ans)

            return g1.cache_triple_product(g2, g3, g.representative(), pt_ans)

    def insert_b_connection(self, h, return_tuple):
        assert isinstance(h, BV_Grouping)

        for i in self.b_connections:
            if self.b_connections[i] == h and self.b_return_tuples[i] == return_tuple:
                return i

        self.number_of_b_connections += 1
        self.b_connections[self.number_of_b_connections] = h
        self.b_return_tuples[self.number_of_b_connections] = return_tuple

        return self.number_of_b_connections

    def reduce(self, reduction_tuple):
        reduction_length, reduction = super().reduce(reduction_tuple)

        if reduction_length == 1:
            return reduction
        else:
            g = self

            if g.is_reduction_cached(reduction_tuple):
                return g.get_cached_reduction(reduction_tuple)

            g_prime = BV_Internal_Grouping(g.level, g.number_of_input_bits, reduction_length)

            reduction_tuple_a = {}

            for i in g.b_connections:
                induced_return_tuple, induced_reduction_tuple = \
                    CFLOBVDD.linear_collapse_classes_leftmost(dict(enumerate([reduction_tuple[v]
                        for v in g.b_return_tuples[i].values()], 1)))

                h = g.b_connections[i].reduce(induced_reduction_tuple)

                position = g_prime.insert_b_connection(h, induced_return_tuple)

                reduction_tuple_a[len(reduction_tuple_a) + 1] = position

            induced_return_tuple, induced_reduction_tuple = \
                CFLOBVDD.linear_collapse_classes_leftmost(reduction_tuple_a)

            g_prime.a_connection = g.a_connection.reduce(induced_reduction_tuple)
            g_prime.a_return_tuple = induced_return_tuple

            return g.cache_reduction(reduction_tuple, g_prime.representative())

class BV_No_Distinction_Proto(BV_Internal_Grouping):
    representatives = {}
    representatives_hits = 0

    def __init__(self, level, number_of_input_bits):
        assert level > 0
        super().__init__(level, number_of_input_bits)

    def representative(level, number_of_input_bits):
        if level == 0:
            return BV_Dont_Care_Grouping.representative(number_of_input_bits)
        elif (level, number_of_input_bits) in BV_No_Distinction_Proto.representatives:
            BV_No_Distinction_Proto.representatives_hits += 1
            return BV_No_Distinction_Proto.representatives[(level, number_of_input_bits)]
        else:
            g = BV_No_Distinction_Proto(level, number_of_input_bits)

            g.a_connection = BV_No_Distinction_Proto.representative(level - 1,
                number_of_input_bits)
            g.a_return_tuple[1] = 1
            g.number_of_b_connections = 1
            g.b_connections[1] = g.a_connection
            g.b_return_tuples[1] = {1:1}

            g.pre_compute_number_of_paths_and_inputs_per_exit()

            BV_No_Distinction_Proto.representatives[(level, number_of_input_bits)] = g

            return g

    def pair_product(self, g2, inorder = True):
        assert isinstance(g2, BV_Grouping)

        g1 = self

        assert g1.level == g2.level
        assert g1.number_of_input_bits == g2.number_of_input_bits

        return BV_Dont_Care_Grouping.pair_product(g1, g2, inorder)

    def triple_product(self, g2, g3, order = 1):
        assert isinstance(g2, BV_Grouping) and isinstance(g3, BV_Grouping)

        g1 = self

        assert g1.level == g2.level == g3.level
        assert g1.number_of_input_bits == g2.number_of_input_bits == g3.number_of_input_bits

        return BV_Dont_Care_Grouping.triple_product(g1, g2, g3, order)

    def reduce(self, reduction_tuple):
        assert reduction_tuple == {1:1}
        return self

class Collapsed_Classes:
    cache = {}
    cache_hits = 0

    def __init__(self, classes):
        self.classes = classes

    def __hash__(self):
        return hash((tuple(self.classes.values()), isinstance(self.classes[1], bool)))

    def __eq__(self, c2):
        return isinstance(c2, Collapsed_Classes) and self.classes == c2.classes

    def are_collapsed_classes_cached(equiv_classes):
        if Collapsed_Classes(equiv_classes) in Collapsed_Classes.cache:
            Collapsed_Classes.cache_hits += 1
            return True
        else:
            return False

    def get_collapsed_classes(equiv_classes):
        return Collapsed_Classes.cache[Collapsed_Classes(equiv_classes)]

    def cache_collapsed_classes(equiv_classes, projected_classes, renumbered_classes):
        collapsed_classes = Collapsed_Classes(equiv_classes)
        if collapsed_classes not in Collapsed_Classes.cache:
            Collapsed_Classes.cache[collapsed_classes] = (projected_classes, renumbered_classes)
        return Collapsed_Classes.cache[collapsed_classes]

class CFLOBVDD:
    max_level = 0

    representatives = {}
    representatives_hits = 0

    def __init__(self, grouping, outputs, number_of_input_bits, number_of_output_bits):
        self.grouping = grouping
        self.outputs = outputs
        self.number_of_input_bits = number_of_input_bits
        self.number_of_output_bits = number_of_output_bits

    def __str__(self):
        return ("CFLOBVDD with\n" +
            f"g: {self.grouping}\n" +
            f"o: {self.outputs}\n" +
            f"n_of_i_b: {self.number_of_input_bits}\n" +
            f"n_of_o_b: {self.number_of_output_bits}")

    def __hash__(self):
        return hash((self.grouping,
            tuple(self.outputs.values()),
            self.number_of_input_bits,
            self.number_of_output_bits))

    def __eq__(self, n2):
        return (isinstance(n2, CFLOBVDD) and
            self.grouping == n2.grouping and
            self.outputs == n2.outputs and
            self.number_of_input_bits == n2.number_of_input_bits and
            self.number_of_output_bits == n2.number_of_output_bits)

    def print_profile():
        print(f"BV_Fork_Grouping cache utilization: {ROABVDD.utilization(BV_Fork_Grouping.representatives_hits, len(BV_Fork_Grouping.representatives))}")
        print(f"BV_Internal_Grouping cache utilization: {ROABVDD.utilization(BV_Internal_Grouping.representatives_hits, len(BV_Internal_Grouping.representatives))}")
        print(f"BV_No_Distinction_Proto cache utilization: {ROABVDD.utilization(BV_No_Distinction_Proto.representatives_hits, len(BV_No_Distinction_Proto.representatives))}")
        print(f"BV_Grouping pair-product cache utilization: {ROABVDD.utilization(BV_Grouping.pair_product_cache_hits, len(BV_Grouping.pair_product_cache))}")
        print(f"BV_Grouping triple-product cache utilization: {ROABVDD.utilization(BV_Grouping.triple_product_cache_hits, len(BV_Grouping.triple_product_cache))}")
        print(f"BV_Grouping reduction cache utilization: {ROABVDD.utilization(BV_Grouping.reduction_cache_hits, len(BV_Grouping.reduction_cache))}")
        print(f"CFLOBVDD collapsed-equivalence-classes cache utilization: {ROABVDD.utilization(Collapsed_Classes.cache_hits, len(Collapsed_Classes.cache))}")
        print(f"CFLOBVDD cache utilization: {ROABVDD.utilization(CFLOBVDD.representatives_hits, len(CFLOBVDD.representatives))}")

    def number_of_paths(self):
        return self.grouping.number_of_paths()

    def number_of_inputs(self):
        return self.grouping.number_of_inputs()

    def number_of_values(self):
        return len(self.outputs)

    def get_printed_paths(paths, full_paths = True):
        printed_paths = []
        for path in paths:
            if isinstance(path[0], int):
                assert isinstance(path[1], int)
                index_i = path[0]
                inputs = path[1]
                if inputs == 0:
                    if full_paths:
                        printed_paths += [f"[dontcare @ {index_i}]"]
                else:
                    printed_paths += ["[" +
                        f"input @ {index_i}: " +
                        "|".join([str(input_value) for input_value in BV_Fork_Grouping.get_input_values(inputs)]) +
                        "]"]
            else:
                a_paths = CFLOBVDD.get_printed_paths(path[0], full_paths)
                b_paths = CFLOBVDD.get_printed_paths(path[1], full_paths)
                if a_paths:
                    if b_paths:
                        printed_paths += ["(" + "&".join(a_paths + b_paths) + ")"]
                    else:
                        printed_paths += a_paths
                elif b_paths:
                    printed_paths += b_paths
        if len(printed_paths) > 1:
            return ["[" + "|".join(printed_paths) + "]"]
        else:
            return printed_paths

    def get_printed_value_paths(self, value = None):
        value_paths = ""
        for exit_i in self.outputs:
            if value is None or self.outputs[exit_i] == value:
                if value_paths:
                    value_paths += "\n"
                value_paths += (f"{self.outputs[exit_i]} <- " +
                    CFLOBVDD.get_printed_paths(self.grouping.get_paths(exit_i))[0])
                if value is not None:
                    # only print specified value
                    break
        return value_paths

    def get_printed_CFLOBVDD(self, value = None):
        return (f"CFLOBVDD:\n" +
            f"{2**self.grouping.level * self.number_of_input_bits} input bits in total\n" +
            f"{2**self.grouping.level} input variables\n" +
            f"{self.number_of_input_bits} input bits per variable\n" +
            f"{self.number_of_values()} output values\n"
            f"{self.number_of_output_bits} output bits per value\n"
            f"{self.number_of_paths()} paths\n" +
            f"{self.number_of_inputs()} inputs\n" +
            f"{self.get_printed_value_paths(value)}")

    def is_consistent(self):
        assert self.grouping.is_consistent()
        assert self.number_of_values() == self.grouping.number_of_exits, f"{self.number_of_values()} == {self.grouping.number_of_exits}"
        assert self.number_of_values() == len(set(self.outputs.values()))
        assert all([0 <= self.outputs[i] < 2**self.number_of_output_bits for i in self.outputs])
        return True

    def representative(grouping, outputs, number_of_input_bits, number_of_output_bits):
        cflobvdd = CFLOBVDD(grouping, outputs, number_of_input_bits, number_of_output_bits)
        if cflobvdd in CFLOBVDD.representatives:
            CFLOBVDD.representatives_hits += 1
        else:
            assert cflobvdd.is_consistent()
            CFLOBVDD.representatives[cflobvdd] = cflobvdd
        return CFLOBVDD.representatives[cflobvdd]

    def is_never_false(self):
        return len(self.outputs) == 1 and self.outputs[1] is True

    def is_never_true(self):
        return len(self.outputs) == 1 and self.outputs[1] is False

    def constant(level, output, number_of_input_bits, number_of_output_bits):
        return CFLOBVDD.representative(
            BV_No_Distinction_Proto.representative(level, number_of_input_bits),
            {1:output},
            number_of_input_bits,
            number_of_output_bits)

    def byte_constant(number_of_input_bytes, output, number_of_input_bits, number_of_output_bits):
        assert number_of_input_bytes > 0
        assert 0 < number_of_input_bits <= 8
        assert 8 % number_of_input_bits == 0

        level = math.ceil(math.log2(number_of_input_bytes * (8 // number_of_input_bits)))

        return CFLOBVDD.constant(level, output, number_of_input_bits, number_of_output_bits)

    def false(level, number_of_input_bits):
        return CFLOBVDD.constant(level, False, number_of_input_bits, 1)

    def true(level, number_of_input_bits):
        return CFLOBVDD.constant(level, True, number_of_input_bits, 1)

    def flip_value_tuple(self):
        assert self.number_of_values() == 2
        return CFLOBVDD.representative(self.grouping,
            {1:self.outputs[2], 2:self.outputs[1]},
            self.number_of_input_bits,
            self.number_of_output_bits)

    def complement(self):
        if self == CFLOBVDD.false(self.grouping.level, self.number_of_input_bits):
            return CFLOBVDD.true(self.grouping.level, self.number_of_input_bits)
        elif self == CFLOBVDD.true(self.grouping.level, self.number_of_input_bits):
            return CFLOBVDD.false(self.grouping.level, self.number_of_input_bits)
        else:
            return self.flip_value_tuple()

    def unary_apply_and_reduce(self, op, number_of_output_bits):
        return self.binary_apply_and_reduce(CFLOBVDD.constant(self.grouping.level,
                0, self.number_of_input_bits, number_of_output_bits),
            lambda x, y: op(x), number_of_output_bits)

    def projection(level, input_i, number_of_input_bits, number_of_output_bits):
        assert 0 <= input_i < 2**level
        assert number_of_output_bits % number_of_input_bits == 0
        assert number_of_output_bits <= (2**level - input_i) * number_of_input_bits
        CFLOBVDD.max_level = max(CFLOBVDD.max_level, level)
        return CFLOBVDD.representative(
            BV_Internal_Grouping.projection_proto(level,
                input_i, number_of_input_bits, number_of_output_bits),
            dict([(output + 1, output) for output in range(2**number_of_output_bits)]),
            number_of_input_bits,
            number_of_output_bits)

    def byte_projection(number_of_input_bytes, byte_i, number_of_input_bits, number_of_output_bits):
        assert number_of_input_bytes > 0
        assert 0 <= byte_i < number_of_input_bytes
        assert 0 < number_of_input_bits <= 8
        assert 8 % number_of_input_bits == 0

        level = math.ceil(math.log2(number_of_input_bytes * (8 // number_of_input_bits)))
        input_i = byte_i * (8 // number_of_input_bits)

        return CFLOBVDD.projection(level, input_i, number_of_input_bits, number_of_output_bits)

    def collapse_classes_leftmost(equiv_classes):
        # legacy code
        if Collapsed_Classes.are_collapsed_classes_cached(equiv_classes):
            return Collapsed_Classes.get_collapsed_classes(equiv_classes)

        # square-time iteration over equivalence classes
        projected_classes = dict(enumerate([equiv_classes[i]
            for i in equiv_classes if i == min([j for j in equiv_classes
                if equiv_classes[j] == equiv_classes[i]])], 1))

        order_of_projected_classes = dict([(projected_classes[i], i)
            for i in projected_classes])

        return Collapsed_Classes.cache_collapsed_classes(equiv_classes,
            projected_classes,
            dict(enumerate([order_of_projected_classes[v] for v in equiv_classes.values()], 1)))

    def linear_collapse_classes_leftmost(equiv_classes):
        if Collapsed_Classes.are_collapsed_classes_cached(equiv_classes):
            return Collapsed_Classes.get_collapsed_classes(equiv_classes)

        leftmost_equiv_class_index = {}

        projected_classes = {}
        renumbered_classes = {}

        # linear-time iteration over equivalence classes
        for index in equiv_classes:
            value = equiv_classes[index]

            if value not in leftmost_equiv_class_index:
                # remember leftmost equivalence class index
                leftmost_equiv_class_index[value] = len(leftmost_equiv_class_index) + 1

                projected_classes[len(leftmost_equiv_class_index)] = value

            renumbered_classes[index] = leftmost_equiv_class_index[value]

        return Collapsed_Classes.cache_collapsed_classes(equiv_classes,
            projected_classes, renumbered_classes)

    def binary_apply_and_reduce(self, n2, op, number_of_output_bits):
        assert isinstance(n2, CFLOBVDD)

        n1 = self

        assert n1.number_of_input_bits == n2.number_of_input_bits

        g, pt = n1.grouping.pair_product(n2.grouping)

        induced_value_tuple, induced_return_tuple = \
            CFLOBVDD.linear_collapse_classes_leftmost(dict([(i,
                op(n1.outputs[pt[i][0]], n2.outputs[pt[i][1]])) for i in pt]))

        return CFLOBVDD.representative(g.reduce(induced_return_tuple),
            induced_value_tuple,
            n1.number_of_input_bits,
            number_of_output_bits)

    def ternary_apply_and_reduce(self, n2, n3, op, number_of_output_bits):
        assert isinstance(n2, CFLOBVDD) and isinstance(n3, CFLOBVDD)

        n1 = self

        assert n1.number_of_input_bits == n2.number_of_input_bits == n3.number_of_input_bits

        g, tt = n1.grouping.triple_product(n2.grouping, n3.grouping)

        induced_value_tuple, induced_return_tuple = \
            CFLOBVDD.linear_collapse_classes_leftmost(dict([(i,
                op(n1.outputs[tt[i][0]], n2.outputs[tt[i][1]], n3.outputs[tt[i][2]])) for i in tt]))

        return CFLOBVDD.representative(g.reduce(induced_return_tuple),
            induced_value_tuple,
            n1.number_of_input_bits,
            number_of_output_bits)

class CFLOBVDD_Test:
    # projection test cases

    CFLOBVDD.projection(0, 0, 1, 1)

    CFLOBVDD.projection(1, 0, 1, 1)
    CFLOBVDD.projection(1, 1, 1, 1)

    CFLOBVDD.projection(1, 0, 1, 2)

    CFLOBVDD.projection(2, 0, 1, 1)
    CFLOBVDD.projection(2, 1, 1, 1)

    CFLOBVDD.projection(2, 0, 1, 2)
    CFLOBVDD.projection(2, 1, 1, 2)
    CFLOBVDD.projection(2, 2, 1, 2)

    CFLOBVDD.projection(2, 0, 2, 2)
    CFLOBVDD.projection(2, 1, 2, 2)
    CFLOBVDD.projection(2, 2, 2, 2)
    CFLOBVDD.projection(2, 3, 2, 2)

    # pairing test cases

    CFLOBVDD.projection(0, 0, 1, 1).grouping.pair_product(CFLOBVDD.projection(0, 0, 1, 1).grouping)

    CFLOBVDD.projection(1, 0, 1, 1).grouping.pair_product(CFLOBVDD.projection(1, 0, 1, 1).grouping)
    CFLOBVDD.projection(1, 0, 1, 1).grouping.pair_product(CFLOBVDD.projection(1, 1, 1, 1).grouping)
    CFLOBVDD.projection(1, 1, 1, 1).grouping.pair_product(CFLOBVDD.projection(1, 0, 1, 1).grouping)
    CFLOBVDD.projection(1, 1, 1, 1).grouping.pair_product(CFLOBVDD.projection(1, 1, 1, 1).grouping)

    CFLOBVDD.projection(1, 0, 1, 2).grouping.pair_product(CFLOBVDD.projection(1, 0, 1, 2).grouping)

    CFLOBVDD.projection(2, 0, 1, 1).grouping.pair_product(CFLOBVDD.projection(2, 0, 1, 1).grouping)
    CFLOBVDD.projection(2, 0, 1, 1).grouping.pair_product(CFLOBVDD.projection(2, 1, 1, 1).grouping)
    CFLOBVDD.projection(2, 1, 1, 1).grouping.pair_product(CFLOBVDD.projection(2, 1, 1, 1).grouping)
    CFLOBVDD.projection(2, 1, 1, 1).grouping.pair_product(CFLOBVDD.projection(2, 0, 1, 1).grouping)

    CFLOBVDD.projection(2, 0, 1, 2).grouping.pair_product(CFLOBVDD.projection(2, 0, 1, 2).grouping)
    CFLOBVDD.projection(2, 0, 1, 2).grouping.pair_product(CFLOBVDD.projection(2, 1, 1, 2).grouping)
    CFLOBVDD.projection(2, 0, 1, 2).grouping.pair_product(CFLOBVDD.projection(2, 2, 1, 2).grouping)
    CFLOBVDD.projection(2, 1, 1, 2).grouping.pair_product(CFLOBVDD.projection(2, 0, 1, 2).grouping)
    CFLOBVDD.projection(2, 1, 1, 2).grouping.pair_product(CFLOBVDD.projection(2, 1, 1, 2).grouping)
    CFLOBVDD.projection(2, 1, 1, 2).grouping.pair_product(CFLOBVDD.projection(2, 2, 1, 2).grouping)
    CFLOBVDD.projection(2, 2, 1, 2).grouping.pair_product(CFLOBVDD.projection(2, 0, 1, 2).grouping)
    CFLOBVDD.projection(2, 2, 1, 2).grouping.pair_product(CFLOBVDD.projection(2, 1, 1, 2).grouping)
    CFLOBVDD.projection(2, 2, 1, 2).grouping.pair_product(CFLOBVDD.projection(2, 2, 1, 2).grouping)
    CFLOBVDD.projection(2, 0, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 0, 2, 2).grouping)
    CFLOBVDD.projection(2, 0, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 1, 2, 2).grouping)
    CFLOBVDD.projection(2, 0, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 2, 2, 2).grouping)
    CFLOBVDD.projection(2, 0, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 3, 2, 2).grouping)
    CFLOBVDD.projection(2, 1, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 0, 2, 2).grouping)
    CFLOBVDD.projection(2, 1, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 1, 2, 2).grouping)
    CFLOBVDD.projection(2, 1, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 2, 2, 2).grouping)
    CFLOBVDD.projection(2, 1, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 3, 2, 2).grouping)
    CFLOBVDD.projection(2, 2, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 0, 2, 2).grouping)
    CFLOBVDD.projection(2, 2, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 1, 2, 2).grouping)
    CFLOBVDD.projection(2, 2, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 2, 2, 2).grouping)
    CFLOBVDD.projection(2, 2, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 3, 2, 2).grouping)
    CFLOBVDD.projection(2, 3, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 0, 2, 2).grouping)
    CFLOBVDD.projection(2, 3, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 1, 2, 2).grouping)
    CFLOBVDD.projection(2, 3, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 2, 2, 2).grouping)
    CFLOBVDD.projection(2, 3, 2, 2).grouping.pair_product(CFLOBVDD.projection(2, 3, 2, 2).grouping)

    # binary apply and reduce test cases

    CFLOBVDD.projection(0, 0, 1, 1).binary_apply_and_reduce(CFLOBVDD.projection(0, 0, 1, 1), lambda x, y: x == y, 1)

    CFLOBVDD.projection(1, 0, 1, 1).binary_apply_and_reduce(CFLOBVDD.projection(1, 0, 1, 1), lambda x, y: x == y, 1)
    CFLOBVDD.projection(1, 0, 1, 1).binary_apply_and_reduce(CFLOBVDD.projection(1, 1, 1, 1), lambda x, y: x == y, 1)
    CFLOBVDD.projection(1, 1, 1, 1).binary_apply_and_reduce(CFLOBVDD.projection(1, 0, 1, 1), lambda x, y: x == y, 1)
    CFLOBVDD.projection(1, 1, 1, 1).binary_apply_and_reduce(CFLOBVDD.projection(1, 1, 1, 1), lambda x, y: x == y, 1)

    CFLOBVDD.projection(1, 0, 1, 2).binary_apply_and_reduce(CFLOBVDD.projection(1, 0, 1, 2), lambda x, y: x == y, 1)

    CFLOBVDD.projection(2, 0, 1, 1).binary_apply_and_reduce(CFLOBVDD.projection(2, 0, 1, 1), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 0, 1, 1).binary_apply_and_reduce(CFLOBVDD.projection(2, 1, 1, 1), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 1, 1, 1).binary_apply_and_reduce(CFLOBVDD.projection(2, 1, 1, 1), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 1, 1, 1).binary_apply_and_reduce(CFLOBVDD.projection(2, 0, 1, 1), lambda x, y: x == y, 1)

    CFLOBVDD.projection(2, 0, 1, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 0, 1, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 0, 1, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 1, 1, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 0, 1, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 2, 1, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 1, 1, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 0, 1, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 1, 1, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 1, 1, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 1, 1, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 2, 1, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 2, 1, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 0, 1, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 2, 1, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 1, 1, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 2, 1, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 2, 1, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 0, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 0, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 0, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 1, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 0, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 2, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 0, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 3, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 1, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 0, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 1, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 1, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 1, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 2, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 1, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 3, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 2, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 0, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 2, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 1, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 2, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 2, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 2, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 3, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 3, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 0, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 3, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 1, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 3, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 2, 2, 2), lambda x, y: x == y, 1)
    CFLOBVDD.projection(2, 3, 2, 2).binary_apply_and_reduce(CFLOBVDD.projection(2, 3, 2, 2), lambda x, y: x == y, 1)

    # ternary apply and reduce test cases

    CFLOBVDD.projection(2, 0, 1, 1).ternary_apply_and_reduce(CFLOBVDD.projection(2, 1, 1, 1),
        CFLOBVDD.projection(2, 2, 1, 1), lambda x, y, z: y if x else z, 1)
    CFLOBVDD.projection(2, 1, 1, 1).ternary_apply_and_reduce(CFLOBVDD.projection(2, 2, 1, 1),
        CFLOBVDD.projection(2, 3, 1, 1), lambda x, y, z: y if x else z, 1)
    CFLOBVDD.projection(2, 0, 1, 1).ternary_apply_and_reduce(CFLOBVDD.projection(2, 2, 1, 1),
        CFLOBVDD.projection(2, 3, 1, 1), lambda x, y, z: y if x else z, 1)
    CFLOBVDD.projection(2, 0, 1, 1).ternary_apply_and_reduce(CFLOBVDD.projection(2, 2, 1, 1),
        CFLOBVDD.projection(2, 3, 1, 1), lambda x, y, z: y if x else z, 1)

    CFLOBVDD.projection(2, 0, 2, 2).ternary_apply_and_reduce(CFLOBVDD.projection(2, 1, 2, 2),
        CFLOBVDD.projection(2, 2, 2, 2), lambda x, y, z: y if x else z, 2)
    CFLOBVDD.projection(2, 1, 2, 2).ternary_apply_and_reduce(CFLOBVDD.projection(2, 2, 2, 2),
        CFLOBVDD.projection(2, 3, 2, 2), lambda x, y, z: y if x else z, 2)
    CFLOBVDD.projection(2, 0, 2, 2).ternary_apply_and_reduce(CFLOBVDD.projection(2, 2, 2, 2),
        CFLOBVDD.projection(2, 3, 2, 2), lambda x, y, z: y if x else z, 2)
    CFLOBVDD.projection(2, 0, 2, 2).ternary_apply_and_reduce(CFLOBVDD.projection(2, 2, 2, 2),
        CFLOBVDD.projection(2, 3, 2, 2), lambda x, y, z: y if x else z, 2)

    CFLOBVDD.projection(2, 0, 4, 4).ternary_apply_and_reduce(CFLOBVDD.projection(2, 1, 4, 4),
        CFLOBVDD.projection(2, 2, 4, 4), lambda x, y, z: y if x else z, 4)
    CFLOBVDD.projection(2, 1, 4, 4).ternary_apply_and_reduce(CFLOBVDD.projection(2, 2, 4, 4),
        CFLOBVDD.projection(2, 3, 4, 4), lambda x, y, z: y if x else z, 4)
    CFLOBVDD.projection(2, 0, 4, 4).ternary_apply_and_reduce(CFLOBVDD.projection(2, 2, 4, 4),
        CFLOBVDD.projection(2, 3, 4, 4), lambda x, y, z: y if x else z, 4)
    CFLOBVDD.projection(2, 0, 4, 4).ternary_apply_and_reduce(CFLOBVDD.projection(2, 2, 4, 4),
        CFLOBVDD.projection(2, 3, 4, 4), lambda x, y, z: y if x else z, 4)

class Values:
    BVDD = False
    ROABVDD = False
    CFLOBVDD = False

    number_of_input_bits = 8

    total_number_of_constants = 0
    current_number_of_inputs = 0
    max_number_of_values = 0

    false = None
    true = None

    def __init__(self, sid_line, value, var_line = None, bvdd = None, roabvdd = None, cflobvdd = None):
        assert isinstance(sid_line, Bitvector)
        self.sid_line = sid_line
        self.bvdd = bvdd
        self.roabvdd = roabvdd
        self.cflobvdd = cflobvdd

        if isinstance(value, bool) or isinstance(value, int):
            assert sid_line.is_unsigned_value(value)

            if Values.BVDD:
                self.bvdd = BVDD.constant(value)
            if Values.ROABVDD:
                self.roabvdd = ROABVDD.constant(value)
            if Values.CFLOBVDD:
                self.cflobvdd = CFLOBVDD.byte_constant(len(Variable.cflobvdd_input),
                    value, Values.number_of_input_bits, self.sid_line.size)

            Values.total_number_of_constants += 1
        elif isinstance(var_line, Variable):
            if Values.BVDD:
                self.bvdd = BVDD.projection()
            if Values.ROABVDD:
                self.roabvdd = ROABVDD.projection(var_line)
            if Values.CFLOBVDD:
                self.cflobvdd = CFLOBVDD.byte_projection(len(Variable.cflobvdd_input),
                    Variable.cflobvdd_index[var_line],
                    Values.number_of_input_bits, self.sid_line.size)

            Values.total_number_of_constants += 2**var_line.sid_line.size

        if Values.BVDD:
            dd = self.bvdd
        elif Values.ROABVDD:
            dd = self.roabvdd
        else:
            assert Values.CFLOBVDD
            dd = self.cflobvdd

        Values.current_number_of_inputs = max(Values.current_number_of_inputs, dd.number_of_inputs())
        Values.max_number_of_values = max(Values.max_number_of_values, dd.number_of_values())
        # for debugging assert self.is_consistent()

    def __str__(self):
        return f"{self.sid_line}: {self.bvdd} {self.roabvdd} {self.cflobvdd}"

    def match_sorts(self, values):
        return self.sid_line.match_sorts(values.sid_line)

    def is_equal(self, values):
        return (type(self) is type(values) and
            self.match_sorts(values) and
            self.bvdd == values.bvdd and
            self.roabvdd == values.roabvdd and
            self.cflobvdd == values.cflobvdd)

    def is_consistent(self):
        return self.bvdd.is_consistent()

    # BVDD adapter

    def get_input_expression(var_line, inputs):
        if inputs == 0:
            return []
        else:
            assert inputs > 0

            inputs_sid_line = Bitvec(btor2.Parser.next_nid(), 2**var_line.sid_line.size,
                var_line.comment, var_line.line_no)
            inputs_zero_line = Constd(btor2.Parser.next_nid(), inputs_sid_line, 0,
                var_line.comment, var_line.line_no)
            inputs_one_line = Constd(btor2.Parser.next_nid(), inputs_sid_line, 1,
                var_line.comment, var_line.line_no)

            if inputs.bit_count() == 1:
                comparison_line = Comparison(btor2.Parser.next_nid(), btor2.OP_EQ, Bool.boolean,
                    Constd(btor2.Parser.next_nid(), var_line.sid_line,
                        int(math.log2(inputs)),
                        var_line.comment, var_line.line_no),
                    var_line,
                    var_line.comment, var_line.line_no)
            else:
                comparison_line = Comparison(btor2.Parser.next_nid(), btor2.OP_NEQ, Bool.boolean,
                    Logical(btor2.Parser.next_nid(), btor2.OP_AND, inputs_sid_line,
                        Constd(btor2.Parser.next_nid(), inputs_sid_line,
                            inputs,
                            var_line.comment, var_line.line_no),
                        Computation(btor2.Parser.next_nid(), btor2.OP_SLL, inputs_sid_line,
                            inputs_one_line,
                            Ext(btor2.Parser.next_nid(), btor2.OP_UEXT, inputs_sid_line, var_line,
                                2**var_line.sid_line.size - var_line.sid_line.size,
                                var_line.comment, var_line.line_no),
                            var_line.comment, var_line.line_no),
                        var_line.comment, var_line.line_no),
                    inputs_zero_line,
                    var_line.comment, var_line.line_no)
            return [comparison_line]

    def get_bvdd_expression(self):
        var_line = Variable.cflobvdd_input[0]
        exp_line = Zero(btor2.Parser.next_nid(), self.sid_line, "unreachable-value", "unreachable value", 0)
        # assert self.bvdd.i2v are sorted by inputs
        for input_value in self.bvdd.i2v:
            exp_line = Ite(btor2.Parser.next_nid(), self.sid_line,
            Values.get_input_expression(var_line, 2**input_value)[0],
            Constd(btor2.Parser.next_nid(), self.sid_line, int(self.bvdd.i2v[input_value]),
                "domain-propagated value", 0),
            exp_line,
            var_line.comment, var_line.line_no)
        return exp_line

    # ROABVDD adapter

    def get_exit_node_expression(sid_line, bvdd, exits):
        if isinstance(bvdd, ROABVDD_Exit):
            assert bvdd in exits, f"exit {bvdd} not in {exits}"
            return Constd(btor2.Parser.next_nid(), sid_line, int(exits[bvdd]),
                "domain-propagated value", 0)
        else:
            assert isinstance(bvdd, ROABVDD_Node)
            exp_line = Zero(btor2.Parser.next_nid(), sid_line, "unreachable-value", "unreachable value", 0)
            # assert bvdd.outputs are sorted by inputs
            for output in bvdd.outputs:
                exp_line = Ite(btor2.Parser.next_nid(), sid_line,
                    Values.get_input_expression(bvdd.var_line, bvdd.outputs[output])[0],
                    Values.get_exit_node_expression(sid_line, output, exits),
                    exp_line,
                    bvdd.var_line.comment, bvdd.var_line.line_no)
            return exp_line

    def get_roabvdd_expression(self):
        return Values.get_exit_node_expression(self.sid_line, self.roabvdd.bvdd, self.roabvdd.exits)

    # CFLOBVDD adapter

    def get_logical_expression(op, paths):
        if not paths:
            return []
        else:
            logical_line = None
            for path_line in paths:
                if logical_line is None:
                    logical_line = path_line
                else:
                    logical_line = Logical(btor2.Parser.next_nid(), op, Bool.boolean,
                        logical_line,
                        path_line,
                        path_line.comment, path_line.line_no)
            return [logical_line]

    def get_path_expression(paths):
        path_expression = []
        for path in paths:
            if isinstance(path[0], int):
                assert isinstance(path[1], int)
                index_i = path[0]
                inputs = path[1]
                path_expression += Values.get_input_expression(Variable.cflobvdd_input[index_i], inputs)
            else:
                a_paths = Values.get_path_expression(path[0])
                b_paths = Values.get_path_expression(path[1])
                path_expression += Values.get_logical_expression(btor2.OP_AND, a_paths + b_paths)
        return Values.get_logical_expression(btor2.OP_OR, path_expression)

    def get_cflobvdd_expression(self):
        cflobvdd = self.cflobvdd
        exp_line = None
        for exit_i in cflobvdd.outputs:
            input_line = Values.get_path_expression(cflobvdd.grouping.get_paths(exit_i))
            output_line = Constd(btor2.Parser.next_nid(), self.sid_line, int(cflobvdd.outputs[exit_i]),
                "domain-propagated value", 0)
            if input_line:
                exp_line = Ite(btor2.Parser.next_nid(), self.sid_line,
                    input_line[0],
                    output_line,
                    Zero(btor2.Parser.next_nid(), self.sid_line,
                        "unreachable-value", "unreachable value", 0)
                            if exp_line is None else exp_line,
                    self.sid_line.comment, self.sid_line.line_no)
            else:
                exp_line = output_line
        return exp_line

    # constraints and expressions

    def FALSE():
        if Values.false is None:
            Values.false = Values(Bool.boolean, False)
        return Values.false

    def TRUE():
        if Values.true is None:
            Values.true = Values(Bool.boolean, True)
        return Values.true

    def is_always_false(self):
        assert isinstance(self.sid_line, Bool)
        return self.is_equal(Values.FALSE())

    def is_always_true(self):
        assert isinstance(self.sid_line, Bool)
        return self.is_equal(Values.TRUE())

    def is_never_false(self):
        assert isinstance(self.sid_line, Bool)
        if Values.BVDD:
            return self.bvdd.is_never_false()
        if Values.ROABVDD:
            return self.roabvdd.is_never_false()
        if Values.CFLOBVDD:
            return self.cflobvdd.is_never_false()

    def is_never_true(self):
        assert isinstance(self.sid_line, Bool)
        if Values.BVDD:
            return self.bvdd.is_never_true()
        if Values.ROABVDD:
            return self.roabvdd.is_never_true()
        if Values.CFLOBVDD:
            return self.cflobvdd.is_never_true()

    def get_false_constraint(self):
        assert isinstance(self.sid_line, Bool)
        roabvdd = None
        if Values.ROABVDD:
            roabvdd = self.roabvdd.get_false_constraint()
        return Values(self.sid_line, None, None, self.bvdd, roabvdd, self.cflobvdd)

    def get_true_constraint(self):
        assert isinstance(self.sid_line, Bool)
        roabvdd = None
        if Values.ROABVDD:
            roabvdd = self.roabvdd.get_true_constraint()
        return Values(self.sid_line, None, None, self.bvdd, roabvdd, self.cflobvdd)

    def get_expression(self):
        # naive transition from domain propagation to bit blasting
        assert isinstance(self.sid_line, Bitvector)
        if Values.BVDD:
            return self.get_bvdd_expression()
        elif Values.ROABVDD:
            return self.get_roabvdd_expression()
        else:
            assert Values.CFLOBVDD
            return self.get_cflobvdd_expression()

    # per-value semantics of value sets

    # unary operators

    def apply_unary(self, sid_line, op):
        bvdd = roabvdd = cflobvdd = None
        if Values.BVDD:
            bvdd = self.bvdd.compute_unary(op)
        if Values.ROABVDD:
            roabvdd = self.roabvdd.compute_unary(sid_line, op)
        if Values.CFLOBVDD:
            cflobvdd = self.cflobvdd.unary_apply_and_reduce(op, sid_line.size)
        return Values(sid_line, None, None, bvdd, roabvdd, cflobvdd)

    def SignExt(self, sid_line):
        assert isinstance(self.sid_line, Bitvec)
        return self.apply_unary(sid_line, lambda x: self.sid_line.get_signed_value(x) % 2**sid_line.size)

    def ZeroExt(self, sid_line):
        assert isinstance(self.sid_line, Bitvec)
        return self.apply_unary(sid_line, lambda x: x)

    def Extract(self, sid_line, u, l):
        assert isinstance(self.sid_line, Bitvec)
        return self.apply_unary(sid_line, lambda x: (x & 2**(u + 1) - 1) >> l)

    def Not(self):
        assert isinstance(self.sid_line, Bool)
        return self.apply_unary(self.sid_line, lambda x: not x)

    def __invert__(self):
        assert isinstance(self.sid_line, Bitvec)
        return self.apply_unary(self.sid_line, lambda x: ~x % 2**self.sid_line.size)

    def Inc(self):
        assert isinstance(self.sid_line, Bitvec)
        return self.apply_unary(self.sid_line, lambda x: (x + 1) % 2**self.sid_line.size)

    def Dec(self):
        assert isinstance(self.sid_line, Bitvec)
        return self.apply_unary(self.sid_line, lambda x: (x - 1) % 2**self.sid_line.size)

    def __neg__(self):
        assert isinstance(self.sid_line, Bitvec)
        return self.apply_unary(self.sid_line, lambda x: -x % 2**self.sid_line.size)

    # binary operators

    def apply_binary(self, sid_line, values, op):
        assert isinstance(values, Values)
        bvdd = roabvdd = cflobvdd = None
        if Values.BVDD:
            bvdd = self.bvdd.compute_binary(op, values.bvdd)
        if Values.ROABVDD:
            roabvdd = self.roabvdd.compute_binary(sid_line, op, values.roabvdd)
        if Values.CFLOBVDD:
            cflobvdd = self.cflobvdd.binary_apply_and_reduce(values.cflobvdd, op, sid_line.size)
        return Values(sid_line, None, None, bvdd, roabvdd, cflobvdd)

    def Implies(self, values):
        assert isinstance(self.sid_line, Bool)
        if self.is_always_false():
            return Values.TRUE()
        else:
            # lazy evaluation of implied values
            assert isinstance(values, Values) and isinstance(values.sid_line, Bool)
            return self.apply_binary(Bool.boolean, values, lambda x, y: (not x) or y)

    def __eq__(self, values):
        assert isinstance(self.sid_line, Bitvector) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(Bool.boolean, values, lambda x, y: x == y)

    def __ne__(self, values):
        assert isinstance(self.sid_line, Bitvector) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(Bool.boolean, values, lambda x, y: x != y)

    def __gt__(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(Bool.boolean, values,
            lambda x, y: self.sid_line.get_signed_value(x) > values.sid_line.get_signed_value(y))

    def UGT(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(Bool.boolean, values, lambda x, y: x > y)

    def __ge__(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(Bool.boolean, values,
            lambda x, y: self.sid_line.get_signed_value(x) >= values.sid_line.get_signed_value(y))

    def UGE(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(Bool.boolean, values, lambda x, y: x >= y)

    def __lt__(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(Bool.boolean, values,
            lambda x, y: self.sid_line.get_signed_value(x) < values.sid_line.get_signed_value(y))

    def ULT(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(Bool.boolean, values, lambda x, y: x < y)

    def __le__(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(Bool.boolean, values,
            lambda x, y: self.sid_line.get_signed_value(x) <= values.sid_line.get_signed_value(y))

    def ULE(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(Bool.boolean, values, lambda x, y: x <= y)

    def And(self, values):
        assert isinstance(self.sid_line, Bool)
        if self.is_always_false():
            return Values.FALSE()
        else:
            # lazy evaluation of second operand
            assert isinstance(values, Values) and isinstance(values.sid_line, Bool)
            return self.apply_binary(Bool.boolean, values, lambda x, y: x and y)

    def Or(self, values):
        assert isinstance(self.sid_line, Bool)
        if self.is_always_true():
            return Values.TRUE()
        else:
            # lazy evaluation of second operand
            assert isinstance(values, Values) and isinstance(values.sid_line, Bool)
            return self.apply_binary(Bool.boolean, values, lambda x, y: x or y)

    def Xor(self, values):
        assert isinstance(self.sid_line, Bool) and isinstance(values.sid_line, Bool)
        return self.apply_binary(Bool.boolean, values, lambda x, y: x != y)

    def __and__(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values, lambda x, y: x & y)

    def __or__(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values, lambda x, y: x | y)

    def __xor__(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values, lambda x, y: x ^ y)

    def __lshift__(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values, lambda x, y: (x << y) % 2**self.sid_line.size)

    def LShR(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values, lambda x, y: (x >> y) % 2**self.sid_line.size)

    def __rshift__(self, values):
        # right shift operator computes arithmetic right shift in Python
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values,
            lambda x, y: (self.sid_line.get_signed_value(x) >> y) % 2**self.sid_line.size)

    def __add__(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values, lambda x, y: (x + y) % 2**self.sid_line.size)

    def __sub__(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values, lambda x, y: (x - y) % 2**self.sid_line.size)

    def __mul__(self, values):
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values, lambda x, y: (x * y) % 2**self.sid_line.size)

    def __truediv__(self, values):
        # using the integer portion of division, not floor division with the // operator,
        # because int(x / y) != x // y in Python if x < 0 or y < 0 since
        # the integer portion of division truncates towards 0 whereas
        # floor division truncates towards negative infinity
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values,
            lambda x, y: (int(self.sid_line.get_signed_value(x) / values.sid_line.get_signed_value(y))
                if not (y == 0 or (self.sid_line.get_signed_value(x) == -2**(self.sid_line.size - 1) and
                    values.sid_line.get_signed_value(y) == -1))
                else -1 if y == 0 else -2**(self.sid_line.size - 1)) % 2**self.sid_line.size)

    def UDiv(self, values):
        # using floor division is ok since x >= 0 and y >= 0
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values,
            lambda x, y: x // y if y != 0 else 2**self.sid_line.size - 1)

    def SRem(self, values):
        # using the integer portion of division, not the % operator,
        # because x % y != x - int(x / y) * y in Python if x < 0 since
        # the % operator in Python computes Euclidean modulus, not remainder,
        # such that x // y * y + x % y == x holds in Python for all x and y even if x < 0
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values,
            lambda x, y: (self.sid_line.get_signed_value(x) -
                    int(self.sid_line.get_signed_value(x) / values.sid_line.get_signed_value(y)) *
                        values.sid_line.get_signed_value(y))
                    % 2**self.sid_line.size
                if not (y == 0 or (self.sid_line.get_signed_value(x) == -2**(self.sid_line.size - 1) and
                    values.sid_line.get_signed_value(y) == -1))
                else x if y == 0 else 0)

    def URem(self, values):
        # using the % operator is ok since x >= 0 and y >= 0
        assert isinstance(self.sid_line, Bitvec) and self.sid_line.match_sorts(values.sid_line)
        return self.apply_binary(self.sid_line, values, lambda x, y: x % y if y != 0 else x)

    def Concat(self, values, sid_line):
        assert isinstance(self.sid_line, Bitvec) and isinstance(values.sid_line, Bitvec)
        return self.apply_binary(sid_line, values, lambda x, y: (x << values.sid_line.size) + y)

    # ternary operators

    def constrain(self, constraint):
        assert isinstance(constraint.sid_line, Bool)
        bvdd = roabvdd = cflobvdd = None
        if Values.BVDD:
            bvdd = self.bvdd.compute_binary(lambda x, y: x, constraint.bvdd)
        if Values.ROABVDD:
            roabvdd = self.roabvdd.constrain(self.sid_line, constraint.roabvdd)
        if Values.CFLOBVDD:
            cflobvdd = self.cflobvdd.binary_apply_and_reduce(constraint.cflobvdd,
                lambda x, y: x, self.sid_line.size)
        return Values(self.sid_line, None, None, bvdd, roabvdd, cflobvdd)

    def merge(self, values2, values3):
        assert isinstance(self.sid_line, Bool)
        assert isinstance(values2, Values) and isinstance(values3, Values)
        assert values2.match_sorts(values3)
        bvdd = roabvdd = cflobvdd = None
        if Values.BVDD:
            bvdd = self.bvdd.compute_ite(values2.bvdd, values3.bvdd)
        if Values.ROABVDD:
            values2 = values2.constrain(self.get_true_constraint())
            values3 = values3.constrain(self.get_false_constraint())
            roabvdd = values2.roabvdd.merge(values2.sid_line, values3.roabvdd)
        if Values.CFLOBVDD:
            cflobvdd = self.cflobvdd.ternary_apply_and_reduce(values2.cflobvdd, values3.cflobvdd,
                lambda x, y, z: y if x else z, values2.sid_line.size)
        return Values(values2.sid_line, None, None, bvdd, roabvdd, cflobvdd)

    def If(self, values2, values3):
        assert isinstance(self.sid_line, Bool)
        if self.is_never_false():
            return values2.constrain(self)
        elif self.is_never_true():
            return values3.constrain(self)
        else:
            # lazy evaluation of true and false case
            return self.merge(values2, values3)

    # bitme solver

    def exclude(self, constraint):
        assert isinstance(constraint.sid_line, Bool)
        roabvdd = None
        if Values.ROABVDD:
            values = self.constrain(constraint.get_true_constraint())
            roabvdd = values.roabvdd.exclude(self.sid_line, constraint.get_false_constraint().roabvdd)
        return Values(self.sid_line, None, None, self.bvdd, roabvdd, self.cflobvdd)

class Instance:
    PROPAGATE = None
    PROPAGATE_UNARY = True
    PROPAGATE_BINARY = True
    PROPAGATE_ITE = True
    LAMBDAS = True

    def __init__(self, instance_of):
        self.instance_of = instance_of
        self.cache_instance = {}
        self.cache_z3_instance = {}
        self.cache_bitwuzla_instance = {}

    def __str__(self):
        string = ""
        for step in self.cache_instance:
            if string:
                string += "\n"
            string += f"{step}: {self.cache_instance[step]}"
        return f"{self.instance_of}{"\n" if string else ""}{string}"

    def has_instance(self, step):
        return step in self.cache_instance

    def get_instance(self, step):
        assert self.has_instance(step)
        return self.cache_instance[step]

    def set_cached_instance(self, instance, step):
        self.cache_instance[step] = instance

    def init_instance(self, instance):
        self.set_cached_instance(instance, -1)

    def set_instance(self, instance, step):
        # bad instances may be overwritten if proven false
        self.set_cached_instance(instance, step)
        if Instance.PROPAGATE is not None:
            self.set_cached_instance(self.get_instance(step).get_values(step), step)

    def get_z3_select(self, step):
        if step not in self.cache_z3_instance:
            instance = self.get_instance(step).get_expression()
            assert step not in self.cache_z3_instance
            domain = instance.get_domain()
            if domain:
                self.cache_z3_instance[step] = z3.Select(instance.get_z3_lambda(),
                    *[state.get_z3_name(step) for state in domain])
            else:
                self.cache_z3_instance[step] = instance.get_z3_lambda()
        return self.cache_z3_instance[step]

    def get_z3_substitute(self, step):
        if step not in self.cache_z3_instance:
            instance = self.get_instance(step).get_expression()
            assert step not in self.cache_z3_instance
            self.cache_z3_instance[step] = instance.get_z3()
            domain = instance.get_domain()
            if domain:
                current_states = [state.get_z3() for state in domain]
                next_states = [state.get_z3_name(step) for state in domain]
                renaming = list(zip(current_states, next_states))

                self.cache_z3_instance[step] = z3.substitute(self.cache_z3_instance[step], renaming)
        return self.cache_z3_instance[step]

    def get_z3_instance(self, step):
        if Instance.LAMBDAS:
            return self.get_z3_select(step)
        else:
            return self.get_z3_substitute(step)

    def get_bitwuzla_select(self, step, tm):
        if step not in self.cache_bitwuzla_instance:
            instance = self.get_instance(step).get_expression()
            assert step not in self.cache_bitwuzla_instance
            domain = instance.get_domain()
            if domain:
                self.cache_bitwuzla_instance[step] = tm.mk_term(bitwuzla.Kind.APPLY,
                    [instance.get_bitwuzla_lambda(tm),
                    *[state.get_bitwuzla_name(step, tm) for state in domain]])
            else:
                self.cache_bitwuzla_instance[step] = instance.get_bitwuzla_lambda(tm)
        return self.cache_bitwuzla_instance[step]

    def get_bitwuzla_substitute(self, step, tm):
        if step not in self.cache_bitwuzla_instance:
            instance = self.get_instance(step).get_expression()
            assert step not in self.cache_bitwuzla_instance
            self.cache_bitwuzla_instance[step] = instance.get_bitwuzla(tm)
            domain = instance.get_domain()
            if domain:
                current_states = [state.get_bitwuzla(tm) for state in domain]
                next_states = [state.get_bitwuzla_name(step, tm) for state in domain]
                renaming = dict(zip(current_states, next_states))

                self.cache_bitwuzla_instance[step] = tm.substitute_term(self.cache_bitwuzla_instance[step], renaming)
        return self.cache_bitwuzla_instance[step]

    def get_bitwuzla_instance(self, step, tm):
        if Instance.LAMBDAS:
            return self.get_bitwuzla_select(step, tm)
        else:
            return self.get_bitwuzla_substitute(step, tm)

class Z3:
    def __init__(self):
        self.z3 = None

    def get_z3(self):
        if self.z3 is None:
            self.z3 = self.model_z3()
        return self.z3

class Bitwuzla:
    def __init__(self):
        self.bitwuzla = None

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            self.bitwuzla = self.model_bitwuzla(tm)
        return self.bitwuzla

class Line(Z3, Bitwuzla, btor2.Line):
    def __init__(self):
        Z3.__init__(self)
        Bitwuzla.__init__(self)

class Sort(Line, btor2.Sort):
    def __init__(self):
        Line.__init__(self)

class Bitvector(Sort, btor2.Bitvector):
    def __init__(self):
        Sort.__init__(self)

class Bool(Bitvector, btor2.Bool):
    def __init__(self, nid, comment, line_no):
        Bitvector.__init__(self)
        btor2.Bool.__init__(self, nid, comment, line_no)

    def model_z3(self):
        return z3.BoolSort()

    def model_bitwuzla(self, tm):
        return tm.mk_bool_sort()

class Bitvec(Bitvector, btor2.Bitvec):
    def __init__(self, nid, size, comment, line_no):
        Bitvector.__init__(self)
        btor2.Bitvec.__init__(self, nid, size, comment, line_no)

    def model_z3(self):
        return z3.BitVecSort(self.size)

    def model_bitwuzla(self, tm):
        return tm.mk_bv_sort(self.size)

class Array(Sort, btor2.Array):
    def __init__(self, nid, array_size_line, element_size_line, comment, line_no):
        Sort.__init__(self)
        btor2.Array.__init__(self, nid, array_size_line, element_size_line, comment, line_no)

    def model_z3(self):
        return z3.ArraySort(self.array_size_line.get_z3(), self.element_size_line.get_z3())

    def model_bitwuzla(self, tm):
        return tm.mk_array_sort(self.array_size_line.get_bitwuzla(tm),
            self.element_size_line.get_bitwuzla(tm))

class Expression(Line, btor2.Expression):
    def __init__(self):
        Line.__init__(self)
        self.cache_values = {}
        self.z3_lambda = None
        self.bitwuzla_lambda = None

    def is_equal(self, exp_line):
        # checking semantical equivalence is delegated to solvers
        return False

    def get_expression(self):
        return self

    def get_values(self, step):
        # versioning needed for support of branching in bitme solver
        if step not in self.cache_values or self.cache_values[step][1] not in Bitme_Solver.versions:
            self.cache_values[step] = (self.compute_values(step), Bitme_Solver.version)
        return self.cache_values[step][0]

    def get_z3_lambda(self):
        if self.z3_lambda is None:
            domain = self.get_domain()
            if domain:
                self.z3_lambda = z3.Lambda([state.get_z3() for state in domain], self.get_z3())
            else:
                self.z3_lambda = self.get_z3()
        return self.z3_lambda

    def get_bitwuzla_lambda(self, tm):
        if self.bitwuzla_lambda is None:
            domain = self.get_domain()
            if domain:
                self.bitwuzla_lambda = tm.mk_term(bitwuzla.Kind.LAMBDA,
                    [*[state.get_bitwuzla(tm) for state in domain], self.get_bitwuzla(tm)])
            else:
                self.bitwuzla_lambda = self.get_bitwuzla(tm)
        return self.bitwuzla_lambda

class Constant(Expression, btor2.Constant):
    def __init__(self):
        Expression.__init__(self)

    def compute_values(self, step):
        assert step == 0
        if Instance.PROPAGATE > 0:
            if isinstance(self.sid_line, Bool):
                return Values.TRUE() if bool(self.value) else Values.FALSE()
            else:
                assert isinstance(self.sid_line, Bitvec)
                return Values(self.sid_line, self.value)
        else:
            return self

    def get_values(self, step):
        return super().get_values(0)

    def model_z3(self):
        if isinstance(self.sid_line, Bool):
            return z3.BoolVal(bool(self.value))
        else:
            return z3.BitVecVal(self.value, self.sid_line.size)

    def model_bitwuzla(self, tm):
        if isinstance(self.sid_line, Bool):
            return tm.mk_true() if bool(self.value) else tm.mk_false()
        else:
            return tm.mk_bv_value(self.sid_line.get_bitwuzla(tm), self.value)

class Zero(Constant, btor2.Zero):
    def __init__(self, nid, sid_line, symbol, comment, line_no):
        Constant.__init__(self)
        btor2.Zero.__init__(self, nid, sid_line, symbol, comment, line_no)

class One(Constant, btor2.One):
    def __init__(self, nid, sid_line, symbol, comment, line_no):
        Constant.__init__(self)
        btor2.One.__init__(self, nid, sid_line, symbol, comment, line_no)

class Constd(Constant, btor2.Constd):
    def __init__(self, nid, sid_line, value, comment, line_no):
        Constant.__init__(self)
        btor2.Constd.__init__(self, nid, sid_line, value, comment, line_no)

class Const(Constant, btor2.Const):
    def __init__(self, nid, sid_line, value, comment, line_no):
        Constant.__init__(self)
        btor2.Const.__init__(self, nid, sid_line, value, comment, line_no)

class Consth(Constant, btor2.Consth):
    def __init__(self, nid, sid_line, value, comment, line_no):
        Constant.__init__(self)
        btor2.Consth.__init__(self, nid, sid_line, value, comment, line_no)

class Constant_Array(Expression, btor2.Constant_Array):
    def __init__(self, sid_line, constant_line):
        Expression.__init__(self)
        btor2.Constant_Array.__init__(self, sid_line, constant_line)

    def get_values(self, step):
        return self

    def model_z3(self):
        return z3.K(self.sid_line.array_size_line.get_z3(), self.constant_line.get_z3())

    def model_bitwuzla(self, tm):
        return tm.mk_const_array(self.sid_line.get_bitwuzla(tm), self.constant_line.get_bitwuzla(tm))

class Variable(Expression, btor2.Variable):
    def __init__(self):
        Expression.__init__(self)

    def compute_values(self, step):
        assert step == 0
        if isinstance(self.sid_line, Bitvector) and self.sid_line.size <= Instance.PROPAGATE:
            return Values(self.sid_line, None, self)
        else:
            return self

    def get_values(self, step):
        return super().get_values(0)

    def model_z3(self):
        return z3.Const(self.name, self.sid_line.get_z3())

class Input(Variable, btor2.Input):
    def __init__(self, nid, sid_line, symbol, comment, line_no, index = None):
        Variable.__init__(self)
        btor2.Input.__init__(self, nid, sid_line, symbol, comment, line_no, index)

    def get_step_name(self, step):
        return self.name

    def get_z3_name(self, step):
        return self.get_z3()

    def get_z3_instance(self, step):
        return self.get_z3()

    def model_bitwuzla(self, tm):
        return tm.mk_const(self.sid_line.get_bitwuzla(tm), self.name)

    def get_bitwuzla_name(self, step, tm):
        return self.get_bitwuzla(tm)

    def get_bitwuzla_instance(self, step, tm):
        return self.get_bitwuzla(tm)

class State(Variable, btor2.State):
    def __init__(self, nid, sid_line, symbol, comment, line_no, index = None):
        Variable.__init__(self)
        btor2.State.__init__(self, nid, sid_line, symbol, comment, line_no, index)
        self.cache_z3_name = {}
        self.cache_bitwuzla_name = {}
        self.instance = Instance(self)
        self.instance.init_instance(self) # initialize with itself upon creation of state

    def has_instance(self, step):
        return self.instance.has_instance(step)

    def get_instance(self, step):
        if self.next_line is None:
            # all instances of an untransitioned state are
            # the state itself, if uninitialized, or its initial state
            return self.instance.get_instance(-1)
        else:
            return self.instance.get_instance(step)

    def set_instance(self, instance, step):
        self.instance.set_instance(instance, step)

    def get_values(self, step):
        if step == -1:
            step = 0
        instance = self.get_instance(step - 1)
        if instance is self:
            # uninitialized state
            return super().get_values(0)
        else:
            return instance

    def get_step_name(self, step):
        return f"{self.name}-{step}"

    def get_z3_name(self, step):
        if step == -1:
            step = 0
        if step not in self.cache_z3_name:
            self.cache_z3_name[step] = z3.Const(self.get_step_name(step), self.sid_line.get_z3())
        return self.cache_z3_name[step]

    def get_z3_instance(self, step):
        if self.next_line is None:
            # all instances of an untransitioned state are
            # the state itself, if uninitialized, or its initial state
            return self.instance.get_z3_instance(-1)
        else:
            return self.instance.get_z3_instance(step)

    def model_bitwuzla(self, tm):
        if self.init_line is None:
            return tm.mk_const(self.sid_line.get_bitwuzla(tm), self.name)
        else:
            return tm.mk_var(self.sid_line.get_bitwuzla(tm), self.name)

    def get_bitwuzla_name(self, step, tm):
        if step == -1:
            step = 0
        if step not in self.cache_bitwuzla_name:
            self.cache_bitwuzla_name[step] = tm.mk_const(self.sid_line.get_bitwuzla(tm),
                self.get_step_name(step))
        return self.cache_bitwuzla_name[step]

    def get_bitwuzla_instance(self, step, tm):
        if self.next_line is None:
            # all instances of an untransitioned state are
            # the state itself, if uninitialized, or its initial state
            return self.instance.get_bitwuzla_instance(-1, tm)
        else:
            return self.instance.get_bitwuzla_instance(step, tm)

class Indexed(Expression, btor2.Indexed):
    def __init__(self):
        Expression.__init__(self)

class Ext(Indexed, btor2.Ext):
    def __init__(self, nid, op, sid_line, arg1_line, w, comment, line_no):
        Indexed.__init__(self)
        btor2.Ext.__init__(self, nid, op, sid_line, arg1_line, w, comment, line_no)

    def compute_values(self, step):
        arg1_value = self.arg1_line.get_values(step)
        if Instance.PROPAGATE_UNARY and isinstance(arg1_value, Values):
            if self.op == btor2.OP_SEXT:
                return arg1_value.SignExt(self.sid_line)
            else:
                assert self.op == btor2.OP_UEXT
                return arg1_value.ZeroExt(self.sid_line)
        else:
            arg1_value = arg1_value.get_expression()
            return self.copy(arg1_value)

    def model_z3(self):
        if self.op == btor2.OP_SEXT:
            return z3.SignExt(self.w, self.arg1_line.get_z3())
        else:
            assert self.op == btor2.OP_UEXT
            return z3.ZeroExt(self.w, self.arg1_line.get_z3())

    def model_bitwuzla(self, tm):
        if self.op == btor2.OP_SEXT:
            bitwuzla_op = bitwuzla.Kind.BV_SIGN_EXTEND
        else:
            assert self.op == btor2.OP_UEXT
            bitwuzla_op = bitwuzla.Kind.BV_ZERO_EXTEND
        return tm.mk_term(bitwuzla_op, [self.arg1_line.get_bitwuzla(tm)], [self.w])

class Slice(Indexed, btor2.Slice):
    def __init__(self, nid, sid_line, arg1_line, u, l, comment, line_no):
        Indexed.__init__(self)
        btor2.Slice.__init__(self, nid, sid_line, arg1_line, u, l, comment, line_no)

    def compute_values(self, step):
        arg1_value = self.arg1_line.get_values(step)
        if Instance.PROPAGATE_UNARY and isinstance(arg1_value, Values):
            return arg1_value.Extract(self.sid_line, self.u, self.l)
        else:
            arg1_value = arg1_value.get_expression()
            return self.copy(arg1_value)

    def model_z3(self):
        return z3.Extract(self.u, self.l, self.arg1_line.get_z3())

    def model_bitwuzla(self, tm):
        return tm.mk_term(bitwuzla.Kind.BV_EXTRACT, [self.arg1_line.get_bitwuzla(tm)], [self.u, self.l])

class Unary(Expression, btor2.Unary):
    def __init__(self, nid, op, sid_line, arg1_line, comment, line_no):
        Expression.__init__(self)
        btor2.Unary.__init__(self, nid, op, sid_line, arg1_line, comment, line_no)

    def compute_values(self, step):
        arg1_value = self.arg1_line.get_values(step)
        if Instance.PROPAGATE_UNARY and isinstance(arg1_value, Values):
            if self.op == btor2.OP_NOT:
                if isinstance(self.sid_line, Bool):
                    return arg1_value.Not()
                else:
                    return ~arg1_value
            elif self.op == btor2.OP_INC:
                return arg1_value.Inc()
            elif self.op == btor2.OP_DEC:
                return arg1_value.Dec()
            else:
                assert self.op == btor2.OP_NEG
                return -arg1_value
        else:
            arg1_value = arg1_value.get_expression()
            return self.copy(arg1_value)

    def model_z3(self):
        z3_arg1 = self.arg1_line.get_z3()
        if self.op == btor2.OP_NOT:
            if isinstance(self.sid_line, Bool):
                return z3.Not(z3_arg1)
            else:
                return ~z3_arg1
        elif self.op == btor2.OP_INC:
            return z3_arg1 + 1
        elif self.op == btor2.OP_DEC:
            return z3_arg1 - 1
        else:
            assert self.op == btor2.OP_NEG
            return -z3_arg1

    def model_bitwuzla(self, tm):
        if self.op == btor2.OP_NOT:
            if isinstance(self.sid_line, Bool):
                bitwuzla_op = bitwuzla.Kind.NOT
            else:
                bitwuzla_op = bitwuzla.Kind.BV_NOT
        elif self.op == btor2.OP_INC:
            bitwuzla_op = bitwuzla.Kind.BV_INC
        elif self.op == btor2.OP_DEC:
            bitwuzla_op = bitwuzla.Kind.BV_DEC
        else:
            assert self.op == btor2.OP_NEG
            bitwuzla_op = bitwuzla.Kind.BV_NEG
        return tm.mk_term(bitwuzla_op, [self.arg1_line.get_bitwuzla(tm)])

class Binary(Expression, btor2.Binary):
    def __init__(self):
        Expression.__init__(self)

class Implies(Binary, btor2.Implies):
    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        Binary.__init__(self)
        btor2.Implies.__init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no)

    def compute_values(self, step):
        arg1_value = self.arg1_line.get_values(step)
        if Instance.PROPAGATE_BINARY and isinstance(arg1_value, Values):
            if arg1_value.is_always_false():
                return arg1_value.Implies(None)
            else:
                # lazy evaluation of implied values
                arg2_value = self.arg2_line.get_values(step)
                if isinstance(arg2_value, Values):
                    return arg1_value.Implies(arg2_value)
        else:
            arg2_value = self.arg2_line.get_values(step)
        arg1_value = arg1_value.get_expression()
        arg2_value = arg2_value.get_expression()
        return self.copy(arg1_value, arg2_value)

    def model_z3(self):
        return z3.Implies(self.arg1_line.get_z3(), self.arg2_line.get_z3())

    def model_bitwuzla(self, tm):
        return tm.mk_term(bitwuzla.Kind.IMPLIES,
            [self.arg1_line.get_bitwuzla(tm), self.arg2_line.get_bitwuzla(tm)])

class Comparison(Binary, btor2.Comparison):
    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        Binary.__init__(self)
        btor2.Comparison.__init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no)

    def compute_values(self, step):
        arg1_value = self.arg1_line.get_values(step)
        arg2_value = self.arg2_line.get_values(step)
        if Instance.PROPAGATE_BINARY:
            if isinstance(arg1_value, Values) and isinstance(arg2_value, Values):
                if self.op == btor2.OP_EQ:
                    return arg1_value == arg2_value
                elif self.op == btor2.OP_NEQ:
                    return arg1_value != arg2_value
                elif self.op == btor2.OP_SGT:
                    return arg1_value > arg2_value
                elif self.op == btor2.OP_UGT:
                    return arg1_value.UGT(arg2_value)
                elif self.op == btor2.OP_SGTE:
                    return arg1_value >= arg2_value
                elif self.op == btor2.OP_UGTE:
                    return arg1_value.UGE(arg2_value)
                elif self.op == btor2.OP_SLT:
                    return arg1_value < arg2_value
                elif self.op == btor2.OP_ULT:
                    return arg1_value.ULT(arg2_value)
                elif self.op == btor2.OP_SLTE:
                    return arg1_value <= arg2_value
                else:
                    assert self.op == btor2.OP_ULTE
                    return arg1_value.ULE(arg2_value)
        arg1_value = arg1_value.get_expression()
        arg2_value = arg2_value.get_expression()
        return self.copy(arg1_value, arg2_value)

    def model_z3(self):
        z3_arg1 = self.arg1_line.get_z3()
        z3_arg2 = self.arg2_line.get_z3()
        if self.op == btor2.OP_EQ:
            return z3_arg1 == z3_arg2
        elif self.op == btor2.OP_NEQ:
            return z3_arg1 != z3_arg2
        elif self.op == btor2.OP_SGT:
            return z3_arg1 > z3_arg2
        elif self.op == btor2.OP_UGT:
            return z3.UGT(z3_arg1, z3_arg2)
        elif self.op == btor2.OP_SGTE:
            return z3_arg1 >= z3_arg2
        elif self.op == btor2.OP_UGTE:
            return z3.UGE(z3_arg1, z3_arg2)
        elif self.op == btor2.OP_SLT:
            return z3_arg1 < z3_arg2
        elif self.op == btor2.OP_ULT:
            return z3.ULT(z3_arg1, z3_arg2)
        elif self.op == btor2.OP_SLTE:
            return z3_arg1 <= z3_arg2
        else:
            assert self.op == btor2.OP_ULTE
            return z3.ULE(z3_arg1, z3_arg2)

    def model_bitwuzla(self, tm):
        if self.op == btor2.OP_EQ:
            bitwuzla_op = bitwuzla.Kind.EQUAL
        elif self.op == btor2.OP_NEQ:
            bitwuzla_op = bitwuzla.Kind.DISTINCT
        elif self.op == btor2.OP_SGT:
            bitwuzla_op = bitwuzla.Kind.BV_SGT
        elif self.op == btor2.OP_UGT:
            bitwuzla_op = bitwuzla.Kind.BV_UGT
        elif self.op == btor2.OP_SGTE:
            bitwuzla_op = bitwuzla.Kind.BV_SGE
        elif self.op == btor2.OP_UGTE:
            bitwuzla_op = bitwuzla.Kind.BV_UGE
        elif self.op == btor2.OP_SLT:
            bitwuzla_op = bitwuzla.Kind.BV_SLT
        elif self.op == btor2.OP_ULT:
            bitwuzla_op = bitwuzla.Kind.BV_ULT
        elif self.op == btor2.OP_SLTE:
            bitwuzla_op = bitwuzla.Kind.BV_SLE
        else:
            assert self.op == btor2.OP_ULTE
            bitwuzla_op = bitwuzla.Kind.BV_ULE
        return tm.mk_term(bitwuzla_op,
            [self.arg1_line.get_bitwuzla(tm), self.arg2_line.get_bitwuzla(tm)])

class Logical(Binary, btor2.Logical):
    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        Binary.__init__(self)
        btor2.Logical.__init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no)

    def compute_values(self, step):
        if Instance.PROPAGATE_BINARY:
            if isinstance(self.sid_line, Bool):
                arg1_value = self.arg1_line.get_values(step)
                if isinstance(arg1_value, Values):
                    if self.op == btor2.OP_AND:
                        if arg1_value.is_always_false():
                            return arg1_value.And(None)
                        else:
                            # lazy evaluation of second operand
                            arg2_value = self.arg2_line.get_values(step)
                            if isinstance(arg2_value, Values):
                                return arg1_value.And(arg2_value)
                    elif self.op == btor2.OP_OR:
                        if arg1_value.is_always_true():
                            return arg1_value.Or(None)
                        else:
                            # lazy evaluation of second operand
                            arg2_value = self.arg2_line.get_values(step)
                            if isinstance(arg2_value, Values):
                                return arg1_value.Or(arg2_value)
                    else:
                        assert self.op == btor2.OP_XOR
                        arg2_value = self.arg2_line.get_values(step)
                        if isinstance(arg2_value, Values):
                            return arg1_value.Xor(arg2_value)
                arg2_value = self.arg2_line.get_values(step)
            else:
                arg1_value = self.arg1_line.get_values(step)
                arg2_value = self.arg2_line.get_values(step)
                if isinstance(arg1_value, Values) and isinstance(arg2_value, Values):
                    if self.op == btor2.OP_AND:
                        return arg1_value & arg2_value
                    elif self.op == btor2.OP_OR:
                        return arg1_value | arg2_value
                    else:
                        assert self.op == btor2.OP_XOR
                        return arg1_value ^ arg2_value
        else:
            arg1_value = self.arg1_line.get_values(step)
            arg2_value = self.arg2_line.get_values(step)
        arg1_value = arg1_value.get_expression()
        arg2_value = arg2_value.get_expression()
        return self.copy(arg1_value, arg2_value)

    def model_z3(self):
        z3_arg1 = self.arg1_line.get_z3()
        z3_arg2 = self.arg2_line.get_z3()
        if isinstance(self.sid_line, Bool):
            if self.op == btor2.OP_AND:
                return z3.And(z3_arg1, z3_arg2)
            elif self.op == btor2.OP_OR:
                return z3.Or(z3_arg1, z3_arg2)
            else:
                assert self.op == btor2.OP_XOR
                return z3.Xor(z3_arg1, z3_arg2)
        else:
            if self.op == btor2.OP_AND:
                return z3_arg1 & z3_arg2
            elif self.op == btor2.OP_OR:
                return z3_arg1 | z3_arg2
            else:
                assert self.op == btor2.OP_XOR
                return z3_arg1 ^ z3_arg2

    def model_bitwuzla(self, tm):
        if isinstance(self.sid_line, Bool):
            if self.op == btor2.OP_AND:
                bitwuzla_op = bitwuzla.Kind.AND
            elif self.op == btor2.OP_OR:
                bitwuzla_op = bitwuzla.Kind.OR
            else:
                assert self.op == btor2.OP_XOR
                bitwuzla_op = bitwuzla.Kind.XOR
        else:
            if self.op == btor2.OP_AND:
                bitwuzla_op = bitwuzla.Kind.BV_AND
            elif self.op == btor2.OP_OR:
                bitwuzla_op = bitwuzla.Kind.BV_OR
            else:
                assert self.op == btor2.OP_XOR
                bitwuzla_op = bitwuzla.Kind.BV_XOR
        return tm.mk_term(bitwuzla_op,
            [self.arg1_line.get_bitwuzla(tm), self.arg2_line.get_bitwuzla(tm)])

class Computation(Binary, btor2.Computation):
    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        Binary.__init__(self)
        btor2.Computation.__init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no)

    def compute_values(self, step):
        arg1_value = self.arg1_line.get_values(step)
        arg2_value = self.arg2_line.get_values(step)
        if Instance.PROPAGATE_BINARY:
            if isinstance(arg1_value, Values) and isinstance(arg2_value, Values):
                if self.op == btor2.OP_SLL:
                    return arg1_value << arg2_value
                elif self.op == btor2.OP_SRL:
                    return arg1_value.LShR(arg2_value)
                elif self.op == btor2.OP_SRA:
                    return arg1_value >> arg2_value
                elif self.op == btor2.OP_ADD:
                    return arg1_value + arg2_value
                elif self.op == btor2.OP_SUB:
                    return arg1_value - arg2_value
                elif self.op == btor2.OP_MUL:
                    return arg1_value * arg2_value
                elif self.op == btor2.OP_SDIV:
                    return arg1_value / arg2_value
                elif self.op == btor2.OP_UDIV:
                    return arg1_value.UDiv(arg2_value)
                elif self.op == btor2.OP_SREM:
                    return arg1_value.SRem(arg2_value)
                else:
                    assert self.op == btor2.OP_UREM
                    return arg1_value.URem(arg2_value)
        arg1_value = arg1_value.get_expression()
        arg2_value = arg2_value.get_expression()
        return self.copy(arg1_value, arg2_value)

    def model_z3(self):
        z3_arg1 = self.arg1_line.get_z3()
        z3_arg2 = self.arg2_line.get_z3()
        if self.op == btor2.OP_SLL:
            return z3_arg1 << z3_arg2
        elif self.op == btor2.OP_SRL:
            return z3.LShR(z3_arg1, z3_arg2)
        elif self.op == btor2.OP_SRA:
            return z3_arg1 >> z3_arg2
        elif self.op == btor2.OP_ADD:
            return z3_arg1 + z3_arg2
        elif self.op == btor2.OP_SUB:
            return z3_arg1 - z3_arg2
        elif self.op == btor2.OP_MUL:
            return z3_arg1 * z3_arg2
        elif self.op == btor2.OP_SDIV:
            return z3_arg1 / z3_arg2
        elif self.op == btor2.OP_UDIV:
            return z3.UDiv(z3_arg1, z3_arg2)
        elif self.op == btor2.OP_SREM:
            return z3.SRem(z3_arg1, z3_arg2)
        else:
            assert self.op == btor2.OP_UREM
            return z3.URem(z3_arg1, z3_arg2)

    def model_bitwuzla(self, tm):
        if self.op == btor2.OP_SLL:
            bitwuzla_op = bitwuzla.Kind.BV_SHL
        elif self.op == btor2.OP_SRL:
            bitwuzla_op = bitwuzla.Kind.BV_SHR
        elif self.op == btor2.OP_SRA:
            bitwuzla_op = bitwuzla.Kind.BV_ASHR
        elif self.op == btor2.OP_ADD:
            bitwuzla_op = bitwuzla.Kind.BV_ADD
        elif self.op == btor2.OP_SUB:
            bitwuzla_op = bitwuzla.Kind.BV_SUB
        elif self.op == btor2.OP_MUL:
            bitwuzla_op = bitwuzla.Kind.BV_MUL
        elif self.op == btor2.OP_SDIV:
            bitwuzla_op = bitwuzla.Kind.BV_SDIV
        elif self.op == btor2.OP_UDIV:
            bitwuzla_op = bitwuzla.Kind.BV_UDIV
        elif self.op == btor2.OP_SREM:
            bitwuzla_op = bitwuzla.Kind.BV_SREM
        else:
            assert self.op == btor2.OP_UREM
            bitwuzla_op = bitwuzla.Kind.BV_UREM
        return tm.mk_term(bitwuzla_op,
            [self.arg1_line.get_bitwuzla(tm), self.arg2_line.get_bitwuzla(tm)])

class Concat(Binary, btor2.Concat):
    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        Binary.__init__(self)
        btor2.Concat.__init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no)

    def compute_values(self, step):
        arg1_value = self.arg1_line.get_values(step)
        arg2_value = self.arg2_line.get_values(step)
        if Instance.PROPAGATE_BINARY:
            if isinstance(arg1_value, Values) and isinstance(arg2_value, Values):
                return arg1_value.Concat(arg2_value, self.sid_line)
        arg1_value = arg1_value.get_expression()
        arg2_value = arg2_value.get_expression()
        return self.copy(arg1_value, arg2_value)

    def model_z3(self):
        return z3.Concat(self.arg1_line.get_z3(), self.arg2_line.get_z3())

    def model_bitwuzla(self, tm):
        return tm.mk_term(bitwuzla.Kind.BV_CONCAT,
            [self.arg1_line.get_bitwuzla(tm), self.arg2_line.get_bitwuzla(tm)])

class Read(Binary, btor2.Read):
    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        Binary.__init__(self)
        btor2.Read.__init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no)

    def compute_values(self, step):
        arg1_value = self.arg1_line.get_values(step).get_expression()
        arg2_value = self.arg2_line.get_values(step).get_expression()
        return self.copy(arg1_value, arg2_value)

    def model_z3(self):
        return z3.Select(self.arg1_line.get_z3(), self.arg2_line.get_z3())

    def model_bitwuzla(self, tm):
        return tm.mk_term(bitwuzla.Kind.ARRAY_SELECT,
            [self.arg1_line.get_bitwuzla(tm), self.arg2_line.get_bitwuzla(tm)])

class Ternary(Expression, btor2.Ternary):
    def __init__(self):
        Expression.__init__(self)

class Ite(Ternary, btor2.Ite):
    def __init__(self, nid, sid_line, arg1_line, arg2_line, arg3_line, comment, line_no):
        Ternary.__init__(self)
        btor2.Ite.__init__(self, nid, sid_line, arg1_line, arg2_line, arg3_line, comment, line_no)
        self.instance = Instance(self)

    def compute_values(self, step):
        arg1_value = self.arg1_line.get_values(step)
        if Instance.PROPAGATE_ITE and isinstance(arg1_value, Values):
            if arg1_value.is_never_false():
                arg2_value = self.arg2_line.get_values(step)
                if isinstance(arg2_value, Values):
                    return arg1_value.If(arg2_value, None)
                elif arg1_value.is_always_true():
                    # true case holds unconditionally
                    return arg2_value.get_expression()
                else:
                    # lazy evaluation of false case into expression
                    arg3_value = self.arg3_line.get_values(step)
            elif arg1_value.is_never_true():
                arg3_value = self.arg3_line.get_values(step)
                if isinstance(arg3_value, Values):
                    return arg1_value.If(None, arg3_value)
                elif arg1_value.is_always_false():
                    # false case holds unconditionally
                    return arg3_value.get_expression()
                else:
                    # lazy evaluation of true case into expression
                    arg2_value = self.arg2_line.get_values(step)
            else:
                # lazy evaluation of true and false case
                arg2_value = self.arg2_line.get_values(step)
                arg3_value = self.arg3_line.get_values(step)
                if isinstance(arg2_value, Values) and isinstance(arg3_value, Values):
                    return arg1_value.If(arg2_value, arg3_value)
        else:
            arg2_value = self.arg2_line.get_values(step)
            arg3_value = self.arg3_line.get_values(step)
        arg1_value = arg1_value.get_expression()
        arg2_value = arg2_value.get_expression()
        arg3_value = arg3_value.get_expression()
        return self.copy(arg1_value, arg2_value, arg3_value)

    def get_instance(self):
        return self.instance

    def get_step(self, step):
        return self.get_instance().get_instance(step)

    def set_step(self, step):
        self.get_instance().set_instance(self, step)

    def model_z3(self):
        return z3.If(self.arg1_line.get_z3(), self.arg2_line.get_z3(), self.arg3_line.get_z3())

    def get_z3_step(self, step):
        # only needed for branching
        self.set_step(step)
        return self.get_instance().get_z3_instance(step)

    def model_bitwuzla(self, tm):
        return tm.mk_term(bitwuzla.Kind.ITE, [self.arg1_line.get_bitwuzla(tm),
            self.arg2_line.get_bitwuzla(tm), self.arg3_line.get_bitwuzla(tm)])

    def get_bitwuzla_step(self, step, tm):
        # only needed for branching
        self.set_step(step)
        return self.get_instance().get_bitwuzla_instance(step, tm)

class Write(Ternary, btor2.Write):
    def __init__(self, nid, sid_line, arg1_line, arg2_line, arg3_line, comment, line_no):
        Ternary.__init__(self)
        btor2.Write.__init__(self, nid, sid_line, arg1_line, arg2_line, arg3_line, comment, line_no)

    def compute_values(self, step):
        arg1_value = self.arg1_line.get_values(step).get_expression()
        arg2_value = self.arg2_line.get_values(step).get_expression()
        arg3_value = self.arg3_line.get_values(step).get_expression()
        return self.copy(arg1_value, arg2_value, arg3_value)

    def model_z3(self):
        return z3.Store(self.arg1_line.get_z3(), self.arg2_line.get_z3(), self.arg3_line.get_z3())

    def model_bitwuzla(self, tm):
        return tm.mk_term(bitwuzla.Kind.ARRAY_STORE,
            [self.arg1_line.get_bitwuzla(tm),
            self.arg2_line.get_bitwuzla(tm),
            self.arg3_line.get_bitwuzla(tm)])

class Transitional(Line, btor2.Transitional):
    def __init__(self):
        Line.__init__(self)

class Init(Transitional, btor2.Init):
    def __init__(self, nid, sid_line, state_line, exp_line, symbol, comment, line_no, array_line = None, index = None):
        Transitional.__init__(self)
        btor2.Init.__init__(self, nid, sid_line, state_line, exp_line, symbol, comment, line_no, array_line, index)

    def get_instance(self):
        return self.state_line.instance

    def set_cached_instance(self, instance, step):
        assert step == 0, f"set cached init with {step} != 0"
        self.get_instance().init_instance(instance)

    def get_step(self, step):
        assert step == 0, f"get init with {step} != 0"
        return self.state_line.get_instance(-1)

    def set_step(self, step):
        assert step == 0, f"set init with {step} != 0"
        self.state_line.set_instance(self.exp_line, -1)

    def get_z3_step(self, step):
        assert step == 0, f"z3 init with {step} != 0"
        self.set_step(0)
        if Instance.PROPAGATE is not None:
            return z3.BoolVal(True)
        else:
            return self.state_line.get_z3_name(0) == self.state_line.get_z3_instance(-1)

    def get_bitwuzla_step(self, step, tm):
        assert step == 0, f"bitwuzla init with {step} != 0"
        self.set_step(0)
        if Instance.PROPAGATE is not None:
            return tm.mk_true()
        else:
            return tm.mk_term(bitwuzla.Kind.EQUAL,
                [self.state_line.get_bitwuzla_name(0, tm),
                self.state_line.get_bitwuzla_instance(-1, tm)])

class Next(Transitional, btor2.Next):
    def __init__(self, nid, sid_line, state_line, exp_line, symbol, comment, line_no, array_line = None, index = None):
        Transitional.__init__(self)
        btor2.Next.__init__(self, nid, sid_line, state_line, exp_line, symbol, comment, line_no, array_line, index)
        self.cache_z3_next_state = {}
        self.cache_z3_is_state_changing = {}
        self.cache_z3_state_is_not_changing = {}
        self.cache_bitwuzla_next_state = {}
        self.cache_bitwuzla_is_state_changing = {}
        self.cache_bitwuzla_state_is_not_changing = {}

    def get_instance(self):
        return self.state_line.instance

    def set_cached_instance(self, instance, step):
        self.get_instance().set_cached_instance(instance, step)

    def get_step(self, step):
        return self.state_line.get_instance(step)

    def set_step(self, step):
        self.state_line.set_instance(self.exp_line, step)

    def is_state_changing(self, step):
        self.set_step(step)
        return self.get_step(step) != self.get_step(step - 1)

    def state_is_not_changing(self, step):
        self.set_step(step)
        return self.get_step(step) == self.get_step(step - 1)

    def get_z3_step(self, step):
        if step not in self.cache_z3_next_state:
            self.set_step(step)
            if Instance.PROPAGATE is not None:
                self.cache_z3_next_state[step] = z3.BoolVal(True)
            else:
                self.cache_z3_next_state[step] = self.state_line.get_z3_name(step + 1) == self.state_line.get_z3_instance(step)
        return self.cache_z3_next_state[step]

    def is_z3_state_changing(self, step):
        if step not in self.cache_z3_is_state_changing:
            self.set_step(step)
            if self.get_step(step).is_equal(self.get_step(step - 1)):
                self.cache_z3_is_state_changing[step] = z3.BoolVal(False)
            else:
                self.cache_z3_is_state_changing[step] = self.state_line.get_z3_instance(step) != self.state_line.get_z3_instance(step - 1)
        return self.cache_z3_is_state_changing[step]

    def z3_state_is_not_changing(self, step):
        if step not in self.cache_z3_state_is_not_changing:
            if Instance.PROPAGATE is not None:
                self.set_step(step)
                self.cache_z3_state_is_not_changing[step] = self.state_line.get_z3_instance(step) == self.state_line.get_z3_instance(step - 1)
            else:
                self.state_line.set_instance(self.state_line, step)
                self.cache_z3_state_is_not_changing[step] = self.state_line.get_z3_name(step + 1) == self.state_line.get_z3_name(step)
        return self.cache_z3_state_is_not_changing[step]

    def get_bitwuzla_step(self, step, tm):
        if step not in self.cache_bitwuzla_next_state:
            self.set_step(step)
            if Instance.PROPAGATE is not None:
                self.cache_bitwuzla_next_state[step] = tm.mk_true()
            else:
                self.cache_bitwuzla_next_state[step] = tm.mk_term(bitwuzla.Kind.EQUAL,
                    [self.state_line.get_bitwuzla_name(step + 1, tm),
                    self.state_line.get_bitwuzla_instance(step, tm)])
        return self.cache_bitwuzla_next_state[step]

    def is_bitwuzla_state_changing(self, step, tm):
        if step not in self.cache_bitwuzla_is_state_changing:
            self.set_step(step)
            if self.get_step(step).is_equal(self.get_step(step - 1)):
                self.cache_bitwuzla_is_state_changing[step] = tm.mk_false()
            else:
                self.cache_bitwuzla_is_state_changing[step] = tm.mk_term(bitwuzla.Kind.DISTINCT,
                    [self.state_line.get_bitwuzla_instance(step, tm),
                    self.state_line.get_bitwuzla_instance(step - 1, tm)])
        return self.cache_bitwuzla_is_state_changing[step]

    def bitwuzla_state_is_not_changing(self, step, tm):
        if step not in self.cache_bitwuzla_state_is_not_changing:
            if Instance.PROPAGATE is not None:
                self.set_step(step)
                self.cache_bitwuzla_state_is_not_changing[step] = tm.mk_term(bitwuzla.Kind.EQUAL,
                    [self.state_line.get_bitwuzla_instance(step, tm),
                    self.state_line.get_bitwuzla_instance(step - 1, tm)])
            else:
                self.state_line.set_instance(self.state_line, step)
                self.cache_bitwuzla_state_is_not_changing[step] = tm.mk_term(bitwuzla.Kind.EQUAL,
                    [self.state_line.get_bitwuzla_name(step + 1, tm),
                    self.state_line.get_bitwuzla_name(step, tm)])
        return self.cache_bitwuzla_state_is_not_changing[step]

class Property(Line, btor2.Property):
    def __init__(self):
        Line.__init__(self)
        self.instance = Instance(self)

    def get_instance(self):
        return self.instance

    def get_step(self, step):
        return self.instance.get_instance(step)

    def set_step(self, step):
        self.instance.set_instance(self.property_line, step)

    def get_z3_step(self, step):
        self.set_step(step)
        return self.get_instance().get_z3_instance(step)

    def get_bitwuzla_step(self, step, tm):
        self.set_step(step)
        return self.get_instance().get_bitwuzla_instance(step, tm)

class Constraint(Property, btor2.Constraint):
    def __init__(self, nid, property_line, symbol, comment, line_no):
        Property.__init__(self)
        btor2.Constraint.__init__(self, nid, property_line, symbol, comment, line_no)

class Bad(Property, btor2.Bad):
    def __init__(self, nid, property_line, symbol, comment, line_no):
        Property.__init__(self)
        btor2.Bad.__init__(self, nid, property_line, symbol, comment, line_no)

# parser interface

class ValuesParser(btor2.Parser):
    def get_class(self, clss_or_keyword):
        if clss_or_keyword is btor2.Bool:
            return Bool
        elif clss_or_keyword is btor2.Bitvec:
            return Bitvec
        elif clss_or_keyword is btor2.Array:
            return Array
        elif clss_or_keyword is btor2.Constant_Array:
            return Constant_Array
        elif clss_or_keyword is btor2.Zero or clss_or_keyword == btor2.Zero.keyword:
            return Zero
        elif clss_or_keyword is btor2.One or clss_or_keyword == btor2.One.keyword:
            return One
        elif clss_or_keyword is btor2.Constd or clss_or_keyword == btor2.Constd.keyword:
            return Constd
        elif clss_or_keyword is btor2.Const or clss_or_keyword == btor2.Const.keyword:
            return Const
        elif clss_or_keyword is btor2.Consth or clss_or_keyword == btor2.Consth.keyword:
            return Consth
        elif clss_or_keyword is btor2.Input or clss_or_keyword == btor2.Input.keyword:
            return Input
        elif clss_or_keyword is btor2.State or clss_or_keyword == btor2.State.keyword:
            return State
        elif clss_or_keyword is btor2.Ext or clss_or_keyword in btor2.Ext.keywords:
            return Ext
        elif clss_or_keyword is btor2.Slice or clss_or_keyword == btor2.Slice.keyword:
            return Slice
        elif clss_or_keyword is btor2.Unary or clss_or_keyword in btor2.Unary.keywords:
            return Unary
        elif clss_or_keyword is btor2.Implies or clss_or_keyword == btor2.Implies.keyword:
            return Implies
        elif clss_or_keyword is btor2.Comparison or clss_or_keyword in btor2.Comparison.keywords:
            return Comparison
        elif clss_or_keyword is btor2.Logical or clss_or_keyword in btor2.Logical.keywords:
            return Logical
        elif clss_or_keyword is btor2.Computation or clss_or_keyword in btor2.Computation.keywords:
            return Computation
        elif clss_or_keyword is btor2.Concat or clss_or_keyword == btor2.Concat.keyword:
            return Concat
        elif clss_or_keyword is btor2.Read or clss_or_keyword == btor2.Read.keyword:
            return Read
        elif clss_or_keyword is btor2.Ite or clss_or_keyword == btor2.Ite.keyword:
            return Ite
        elif clss_or_keyword is btor2.Write or clss_or_keyword == btor2.Write.keyword:
            return Write
        elif clss_or_keyword is btor2.Init or clss_or_keyword == btor2.Init.keyword:
            return Init
        elif clss_or_keyword is btor2.Next or clss_or_keyword == btor2.Next.keyword:
            return Next
        elif clss_or_keyword is btor2.Constraint or clss_or_keyword == btor2.Constraint.keyword:
            return Constraint
        elif clss_or_keyword is btor2.Bad or clss_or_keyword == btor2.Bad.keyword:
            return Bad

# console output

def get_step(step, level):
    if step is None or level is None:
        return ""
    elif level == 0:
        return f"{step}: "
    else:
        return f"{step}-{level}: "

last_message_length = 0

def print_message(message, step = None, level = None):
    global last_message_length
    if last_message_length > 0:
        print("\r%s" % (" " * last_message_length), end='\r')
    message = f"{get_step(step, level)}{message}"
    print(message, end='', flush=True)
    last_message_length = len(message) if message[-1:] != '\n' else 0

def print_separator(separator, step = None, level = None):
    print_message(f"{separator * (80 - len(get_step(step, level)))}\n", step, level)

def print_message_with_propagation_profile(message, step = None, level = None):
    if Instance.PROPAGATE is not None:
        string = f"({Values.total_number_of_constants} constants, "
        string += f"{Values.current_number_of_inputs} inputs, "
        string += f"{Values.max_number_of_values} values, "
        if Values.ROABVDD:
            string += f"{len(ROABVDD_Exit.exits)} exits, {len(ROABVDD_Node.bvdds)} nodes, "
        string += f"{Expression.total_number_of_generated_expressions} expressions) {message}"
        print_message(string, step, level)
        Values.current_number_of_inputs = 0
    else:
        print_message(message, step, level)

# Z3 and bitwuzla solver interface

class Solver:
    def __init__(self, solver):
        self.solver = solver

    def push(self):
        self.solver.push()

    def pop(self):
        self.solver.pop()

class Z3_Solver(Solver):
    def __init__(self):
        super().__init__(z3.Solver())

    def assert_this(self, assertions, step):
        for assertion in assertions:
            self.solver.add(assertion.get_z3_step(step))

    def assert_not_this(self, assertions, step):
        for assertion in assertions:
            self.solver.add(assertion.get_z3_step(step) == False)

    def simplify(self):
        # no effective simplification yet found in Z3
        pass

    def prove(self):
        return self.solver.check()

    def is_SAT(self, result):
        return result == z3.sat

    def is_UNSAT(self, result):
        return result == z3.unsat

    def assert_is_state_changing(self, next_line, step):
        self.solver.add(next_line.is_z3_state_changing(step))

    def assert_state_is_not_changing(self, next_line, step):
        self.solver.add(next_line.z3_state_is_not_changing(step))

    def print_pc(self, pc, step, level):
        self.prove()
        model = self.solver.model()
        print_message(f"{pc}\n", step, level)
        print_message("%s = 0x%X\n" % (pc.get_z3_name(step),
            int(model.evaluate(pc.get_z3_instance(step - 1)).as_long())), step, level)

    def print_inputs(self, inputs, step, level):
        model = self.solver.model()
        for input_variable in inputs.values():
            # only print value of uninitialized states
            print_message(f"{input_variable}\n", step, level)
            print_message("%s = %s\n" % (input_variable.get_z3_name(step),
                model.evaluate(input_variable.get_z3_instance(step - 1))), step, level)

    def eval_inputs(self, inputs, step):
        model = self.solver.model()

        input_values = dict()
        for input_variable in inputs.values():
            z3_inst = input_variable.get_z3_instance(step - 1)
            if isinstance(input_variable.sid_line, Array):
                # Mimic the output of the BVDD naming scheme for consistency
                for index in range(2**input_variable.sid_line.array_size_line.size):
                    input_values[f"{input_variable.symbol}-{index}"] = model.evaluate(z3_inst[index], model_completion=True).as_long()
            else:
                input_values[input_variable.symbol] = model.evaluate(z3_inst, model_completion=True).as_long()

        return input_values

class Bitwuzla_Solver(Solver):
    def __init__(self):
        self.tm = bitwuzla.TermManager()
        self.options = bitwuzla.Options()
        self.options.set(bitwuzla.Option.PRODUCE_MODELS, True)
        super().__init__(bitwuzla.Bitwuzla(self.tm, self.options))

    def assert_this(self, assertions, step):
        for assertion in assertions:
            self.solver.assert_formula(assertion.get_bitwuzla_step(step, self.tm))

    def assert_not_this(self, assertions, step):
        for assertion in assertions:
            self.solver.assert_formula(self.tm.mk_term(bitwuzla.Kind.NOT, [assertion.get_bitwuzla_step(step, self.tm)]))

    def simplify(self):
        # possibly increases performance
        self.prove()

    def prove(self):
        return self.solver.check_sat()

    def is_SAT(self, result):
        return result is bitwuzla.Result.SAT

    def is_UNSAT(self, result):
        return result is bitwuzla.Result.UNSAT

    def assert_is_state_changing(self, next_line, step):
        self.solver.assert_formula(next_line.is_bitwuzla_state_changing(step, self.tm))

    def assert_state_is_not_changing(self, next_line, step):
        self.solver.assert_formula(next_line.bitwuzla_state_is_not_changing(step, self.tm))

    def print_pc(self, pc, step, level):
        self.prove()
        pc_value = int(self.solver.get_value(pc.get_bitwuzla_instance(step - 1, self.tm)).value(16), 16)
        print_message(f"{pc}\n", step, level)
        print_message("%s = 0x%X\n" % (pc.get_bitwuzla_name(step, self.tm), pc_value), step, level)

    def print_inputs(self, inputs, step, level):
        for input_variable in inputs.values():
            # only print value of uninitialized states
            print_message(f"{input_variable}\n", step, level)
            print_message("%s = %s\n" % (input_variable.get_bitwuzla_name(step, self.tm),
                self.solver.get_value(input_variable.get_bitwuzla_instance(step - 1, self.tm))),
                step, level)

    def eval_inputs(self, inputs, step):
        input_values = dict()
        for input_variable in inputs.values():
            bwz_inst = input_variable.get_bitwuzla_instance(step - 1, self.tm)
            if isinstance(input_variable.sid_line, Array):
                # Mimic the output of the BVDD naming scheme for consistency
                for index in range(2**input_variable.sid_line.array_size_line.size):
                    input_values[f"{input_variable.symbol}-{index}"] = self.solver.get_value(bwz_inst[index])
            else:
                input_values[input_variable.symbol] = self.solver.get_value(bwz_inst)

        return input_values

# bitme solver

class Bitme_Solver(Solver):
    versions = {0:None}
    version = 0
    bump = 1

    def __init__(self, z3_solver, bitwuzla_solver, exclude):
        self.z3_solver = z3_solver
        self.bitwuzla_solver = bitwuzla_solver
        self.fallback = False
        self.stack = []
        self.constraint = Values.TRUE()
        self.proven = {}
        self.unproven = {}
        self.exclude = exclude

    def push(self):
        if self.fallback:
            if self.z3_solver:
                self.z3_solver.push()
            if self.bitwuzla_solver:
                self.bitwuzla_solver.push()
        else:
            # push before proving to enable fallback to other solvers
            self.stack.append((self.constraint, self.proven | self.unproven))
            self.prove() # may trigger fallback to other solvers
            self.proven = {}
            assert not self.unproven
            if not self.fallback:
                # proving may have strengthened constraint
                _, proven = self.stack.pop()
                self.stack.append((self.constraint, proven))
                Bitme_Solver.version = Bitme_Solver.bump
                Bitme_Solver.bump += 1
                Bitme_Solver.versions[Bitme_Solver.version] = None

    def pop(self):
        if self.fallback:
            if self.z3_solver:
                self.z3_solver.pop()
            if self.bitwuzla_solver:
                self.bitwuzla_solver.pop()
        else:
            assert self.stack
            self.constraint, self.proven = self.stack.pop()
            self.unproven = {}
            del Bitme_Solver.versions[Bitme_Solver.version]
            Bitme_Solver.version = list(Bitme_Solver.versions)[-1]

    def assert_this(self, assertions, step):
        if self.fallback:
            if self.z3_solver:
                self.z3_solver.assert_this(assertions, step)
            if self.bitwuzla_solver:
                self.bitwuzla_solver.assert_this(assertions, step)
        else:
            for assertion in assertions:
                if step not in self.unproven:
                    self.unproven[step] = {assertion:True}
                else:
                    assert assertion not in self.unproven[step]
                    self.unproven[step] |= {assertion:True}

    def assert_not_this(self, assertions, step):
        if self.fallback:
            if self.z3_solver:
                self.z3_solver.assert_not_this(assertions, step)
            if self.bitwuzla_solver:
                self.bitwuzla_solver.assert_not_this(assertions, step)
        else:
            for assertion in assertions:
                if step not in self.unproven:
                    self.unproven[step] = {assertion:False}
                else:
                    assert assertion not in self.unproven[step]
                    self.unproven[step] |= {assertion:False}

    def simplify(self):
        if self.fallback:
            if self.z3_solver:
                self.z3_solver.simplify()
            if self.bitwuzla_solver:
                self.bitwuzla_solver.simplify()

    def solve(self):
        self.fallback = True
        self.constraint = Values.TRUE()
        self.proven |= self.unproven
        self.unproven = {}
        self.stack.append((None, self.proven))
        for _, assertions in self.stack:
            for step in assertions:
                for assertion in assertions[step]:
                    if assertions[step][assertion]:
                        self.assert_this([assertion], step)
                    else:
                        self.assert_not_this([assertion], step)
            if assertions is not self.proven:
                # push with other solvers except for top of stack
                self.push()
        self.proven = {}
        self.stack = []
        return self.prove()

    def prove(self):
        if self.fallback:
            z3_SAT = False
            if self.z3_solver:
                result = self.z3_solver.prove()
                z3_SAT = self.z3_solver.is_SAT(result)
            if self.bitwuzla_solver:
                result = self.bitwuzla_solver.prove()
                bitwuzla_SAT = self.bitwuzla_solver.is_SAT(result)
                assert not self.z3_solver or z3_SAT == bitwuzla_SAT
                return bitwuzla_SAT
            return z3_SAT
        else:
            for step in self.unproven:
                for assertion in self.unproven[step]:
                    if isinstance(assertion, Transitional):
                        assertion.set_step(step)
                for assertion in self.unproven[step]:
                    if isinstance(assertion, Ite) or isinstance(assertion, Property):
                        assertion.set_step(step)
                        condition = assertion.get_step(step)
                        assert isinstance(condition.sid_line, Bool)
                        if isinstance(condition, Values):
                            if self.unproven[step][assertion] is True:
                                self.constraint = condition.And(self.constraint)
                            else:
                                assert self.unproven[step][assertion] is False
                                self.constraint = condition.Not().And(self.constraint)
                        else:
                            return self.solve()
                    elif isinstance(assertion, Values):
                         # support termination check
                         assert isinstance(assertion.sid_line, Bool)
                         assert self.unproven[step][assertion] is True
                         self.constraint = assertion.And(self.constraint)
                if self.exclude:
                    if not self.constraint.is_never_false() and not self.constraint.is_never_true():
                        for assertion in self.unproven[step]:
                            if isinstance(assertion, Transitional):
                                values = assertion.get_step(step)
                                if isinstance(values, Values):
                                    values = values.exclude(self.constraint)
                                    # constraining cached instances requires versioning cached values
                                    assertion.set_cached_instance(values, step)
                                else:
                                    return self.solve()
            self.proven |= self.unproven
            self.unproven = {}
            return not self.constraint.is_never_false() and not self.constraint.is_never_true()

    def is_SAT(self, result):
        return result

    def is_UNSAT(self, result):
        return not result

    def assert_is_state_changing(self, next_line, step):
        if self.fallback:
            if self.z3_solver:
                self.z3_solver.assert_is_state_changing(next_line, step)
            if self.bitwuzla_solver:
                self.bitwuzla_solver.assert_is_state_changing(next_line, step)
        else:
            self.assert_this([next_line.is_state_changing(step)], step)

    def assert_state_is_not_changing(self, next_line, step):
        if self.fallback:
            if self.z3_solver:
                self.z3_solver.assert_state_is_not_changing(next_line, step)
            if self.bitwuzla_solver:
                self.bitwuzla_solver.assert_state_is_not_changing(next_line, step)
        else:
            self.assert_this([next_line.state_is_not_changing(step)], step)

    def print_pc(self, pc, step, level):
        if self.fallback:
            if self.z3_solver:
                self.z3_solver.print_pc(pc, step, level)
            if self.bitwuzla_solver:
                self.bitwuzla_solver.print_pc(pc, step, level)
        else:
            self.prove()
            pc_value = pc.get_instance(step - 1)
            print_message(f"{pc}\n", step, level)
            print_message("%s = %s\n" % (pc.get_step_name(step), pc_value), step, level)

    def print_inputs(self, inputs, step, level):
        if self.fallback:
            if self.z3_solver:
                self.z3_solver.print_inputs(inputs, step, level)
            if self.bitwuzla_solver:
                self.bitwuzla_solver.print_inputs(inputs, step, level)
        elif Values.BVDD:
            print(self.constraint.bvdd.get_printed_BVDD(True))
        elif Values.ROABVDD:
            print(self.constraint.get_true_constraint())
        else:
            assert Values.CFLOBVDD
            print(self.constraint.cflobvdd.get_printed_CFLOBVDD(True))

    def eval_inputs(self, inputs, step):
        if self.fallback:
            if self.z3_solver:
                return self.z3_solver.eval_inputs(inputs, step)
            if self.bitwuzla_solver:
                return self.bitwuzla_solver.eval_inputs(inputs, step)
        elif Values.ROABVDD:
            sample = self.constraint.get_true_constraint().bvdd.sample_input_values()

            input_values = dict()
            for input_variable in inputs.values():
                if input_variable in sample:
                    input_values[input_variable.symbol] = sample[input_variable]
                    del sample[input_variable]
                else:
                    # The variable doesn't appear in our sample of the BVDD - this means any value will do
                    input_values[input_variable.symbol] = 0x42 # ord("A"), but also a nice magic value

            assert len(sample) == 0, "sanity check: all branches of the BVDD must be on input values"

            return input_values
        else:
            # TODO
            pass

# bitme bounded model checker

def branching_bmc(solver, kmin, kmax, args, step, level):
    while step <= kmax or args.analyzor:
        # check model up to kmax steps
        # in analyzor mode we keep going until we find a bad input

        if args.print_pc and State.pc:
            # print current program counter value of single-core rotor model
            solver.print_pc(State.pc, step, level)

        # assert all constraints
        for constraint in Constraint.constraints.values():
            print_message_with_propagation_profile(constraint.symbol, step, level)
            solver.assert_this([constraint], step)
            result = solver.prove()
            if solver.is_UNSAT(result):
                print_separator('v', step, level)
                print_message(f"{constraint}\n", step, level)
                if Instance.PROPAGATE is not None:
                    print_message_with_propagation_profile("propagation profile\n", step, level)
                print_separator('^', step, level)
                return

        if step >= kmin:
            # check bad properties from kmin on
            for bad in Bad.bads.values():
                print_message_with_propagation_profile(bad.symbol, step, level)
                solver.push()
                solver.assert_this([bad], step)
                result = solver.prove()
                if solver.is_SAT(result):
                    print_separator('v', step, level)
                    print_message(f"{bad}\n", step, level)
                    solver.print_inputs(Variable.inputs, step, level)
                    if Instance.PROPAGATE is not None:
                        print_message_with_propagation_profile("propagation profile\n", step, level)
                    print_separator('^', step, level)

                    if args.analyzor:
                        print("Found bad input; exiting from analyzor mode...")
                        print(f"analyzor#step={step}")
                        print(f"analyzor#bad={bad.symbol}")

                        input_vals = solver.eval_inputs(Variable.inputs, step)
                        for (name, val) in input_vals.items():
                            print(f"analyzor#input:{name}={val}")

                        return

                solver.pop()

        if not args.unconstraining_bad:
            # assert all bad properties as negated constraints
            solver.assert_not_this(Bad.bads.values(), step)

        if args.check_termination and step >= kmin:
            state_change = False
            for next_line in Next.nexts.values():
                # check if state changes
                solver.push()
                solver.assert_is_state_changing(next_line, step)
                result = solver.prove()
                solver.pop()
                if solver.is_SAT(result):
                    state_change = True
                    print_message(f"state change: {next_line}\n", step, level)
                    # compute next step
                    solver.assert_this([next_line], step)
                else:
                    solver.assert_state_is_not_changing(next_line, step)
                if not state_change and next_line is list(Next.nexts.values())[-1]:
                    print_message_with_propagation_profile("no states changed: terminating\n", step, level)
                    return
        else:
            # compute next step
            solver.assert_this(Next.nexts.values(), step)

        if args.print_transition:
            print_message_with_propagation_profile("transitioning\n", step, level)
        else:
            print_message("transitioning", step, level)
        solver.simplify()

        if args.branching and Ite.branching_conditions and Ite.non_branching_conditions:
            print_message_with_propagation_profile("checking branching", step, level)

            solver.push()
            solver.assert_this([Ite.branching_conditions], step)
            branching_result = solver.is_SAT(solver.prove())
            solver.pop()

            solver.push()
            solver.assert_not_this([Ite.non_branching_conditions], step)
            non_branching_result = solver.is_SAT(solver.prove())
            solver.pop()

            if branching_result != non_branching_result:
                if branching_result:
                    solver.assert_this([Ite.branching_conditions], step)
                elif non_branching_result:
                    solver.assert_not_this([Ite.non_branching_conditions], step)

            if branching_result and non_branching_result:
                print_separator('v', step, level)
                print_message("branching:\n", step, level)

                solver.push()
                solver.assert_this([Ite.branching_conditions], step)
                branching_bmc(solver, kmin, kmax, args, step + 1, level + 1)
                solver.pop()

                print_separator('-', step, level)
                print_message("not branching:\n", step, level)

                solver.push()
                solver.assert_not_this([Ite.non_branching_conditions], step)
                branching_bmc(solver, kmin, kmax, args, step + 1, level + 1)
                solver.pop()

                print_separator('^', step, level)
                return

        step += 1

    print_message_with_propagation_profile("reached kmax: terminating\n", step, level)

def bmc(solver, kmin, kmax, args):
    print_separator('-')
    print_message(f"bounded model checking: -kmin {kmin} -kmax {kmax}\n")
    print_separator('-')

    # initialize all states
    solver.assert_this(Init.inits.values(), 0)

    print_message("initializing", 0, 0)
    solver.simplify()

    branching_bmc(solver, kmin, kmax, args, 0, 0)

import sys

def try_rotor():
    if is_rotor_present and len(sys.argv) > 1 and sys.argv[1] == '--rotor':
        # just run rotor
        argv = [sys.argv[0]] + sys.argv[2:] # remove --rotor but keep all other arguments
        rotor.main.argtypes = ctypes.c_int, ctypes.POINTER(ctypes.c_char_p)
        rotor.main(len(argv), (ctypes.c_char_p * len(argv))(*[arg.encode('utf-8') for arg in argv]))
        exit(0)

import argparse

def main():
    try_rotor()

    parser = argparse.ArgumentParser(prog='bitme',
        description="bitme is a bounded model checker for BTOR2 models, see github.com/cksystemsteaching/selfie for more details.",
        epilog="bitme is designed to work with BTOR2 models generated by rotor for modeling RISC-V machines and RISC-V code.")

    parser.add_argument('modelfile', type=argparse.FileType('r'))
    parser.add_argument('outputfile', nargs='?', type=argparse.FileType('w', encoding='UTF-8'))

    parser.add_argument('-analyzor', action='store_true')
    parser.add_argument('--use-Z3', action='store_true')
    parser.add_argument('--use-bitwuzla', action='store_true')
    parser.add_argument('--use-BVDD', action='store_true')
    parser.add_argument('--use-ROABVDD', action='store_true')
    parser.add_argument('--use-CFLOBVDD', nargs='?', default=None, const=8, type=int)

    parser.add_argument('-propagate', nargs=1, type=int)
    parser.add_argument('--substitute', action='store_true')

    parser.add_argument('-array', nargs=1, type=int)
    parser.add_argument('--recursive-array', action='store_true')

    parser.add_argument('-kmin', nargs=1, type=int)
    parser.add_argument('-kmax', nargs=1, type=int)

    parser.add_argument('--print-pc', action='store_true') # only for rotor models
    parser.add_argument('--check-termination', action='store_true')
    parser.add_argument('--unconstraining-bad', action='store_true')
    parser.add_argument('--print-transition', action='store_true')
    parser.add_argument('--branching', action='store_true') # only for rotor models

    parser.add_argument('--exclude', action='store_true') # only for ROABVDDs

    args = parser.parse_args()

    Instance.PROPAGATE = args.propagate[0] if args.propagate and args.propagate[0] >= 0 else None
    Instance.LAMBDAS = not args.substitute

    btor2.Array.ARRAY_SIZE_BOUND = args.array[0] if args.array else 0
    btor2.Read.READ_ARRAY_ITERATIVELY = not args.recursive_array

    print_separator('#')

    are_there_state_transitions = ValuesParser().parse_btor2(args.modelfile, args.outputfile)

    if args.kmin or args.kmax or args.analyzor:
        kmin = args.kmin[0] if args.kmin else 0
        kmax = args.kmax[0] if args.kmax else 0

        if are_there_state_transitions:
            kmax = max(kmin, kmax)
        else:
            kmin = kmax = 0

        z3_solver = None
        bitwuzla_solver = None

        if is_Z3_present:
            z3_solver = Z3_Solver()
        if is_bitwuzla_present:
            bitwuzla_solver = Bitwuzla_Solver()

        if args.use_BVDD:
            Values.BVDD = True
        if args.use_ROABVDD:
            Values.ROABVDD = True
        if args.use_CFLOBVDD:
            Values.CFLOBVDD = True
            Values.number_of_input_bits = args.use_CFLOBVDD

        if not args.use_BVDD and not args.use_ROABVDD and not args.use_CFLOBVDD:
            Values.ROABVDD = True

        bitme_solver = Bitme_Solver(z3_solver, bitwuzla_solver, args.exclude)

        if not args.use_Z3 and not args.use_bitwuzla:
            if Variable.cflobvdd_input:
                bmc(bitme_solver, kmin, kmax, args)

                print_separator('-')
                if Values.ROABVDD:
                    ROABVDD.print_profile()
                if Values.CFLOBVDD:
                    CFLOBVDD.print_profile()
            else:
                print_separator('-')
                print("model input is unmapped, consider increasing -array")
        else:
            if args.use_Z3 and is_Z3_present:
                bmc(z3_solver, kmin, kmax, args)
            if args.use_bitwuzla and is_bitwuzla_present:
                bmc(bitwuzla_solver, kmin, kmax, args)

    print_separator('#')

if __name__ == '__main__':
    main()
