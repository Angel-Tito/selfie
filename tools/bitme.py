#!/usr/bin/env python3

# Copyright (c) the Selfie Project authors. All rights reserved.
# Please see the AUTHORS file for details. Use of this source code is
# governed by a BSD license that can be found in the LICENSE file.

# Selfie is a project of the Computational Systems Group at the
# Department of Computer Sciences of the University of Salzburg
# in Austria. For further information and code please refer to:

# selfie.cs.uni-salzburg.at

# Bitme is a bounded model checker for BTOR2 models using
# the Z3 and bitwuzla SMT solvers as reasoning engines.

# Bitme is designed to work with BTOR2 models generated by rotor
# for modeling RISC-V machines and RISC-V code. Rotor is a tool
# that is part of the selfie system.

# ------------------------------------------------------------

# for debugging segfaults: import faulthandler; faulthandler.enable()

import ctypes

try:
    rotor = ctypes.cdll.LoadLibrary("rotor")
    is_rotor_present = True
except OSError:
    print("rotor is not available")
    is_rotor_present = False

# requires Z3 and the Z3 Python API:
# pip install z3-solver

try:
    import z3
    is_Z3_present = True
except ImportError:
    print("Z3 is not available")
    is_Z3_present = False

# requires bitwuzla and the bitwuzla Python API:
# cd bitwuzla
# pip install .

try:
    import bitwuzla
    is_bitwuzla_present = True
except ImportError:
    print("bitwuzla is not available")
    is_bitwuzla_present = False

# BTOR2, Z3, and bitwuzla models

import math

# supported BTOR2 keywords and operators

BITVEC = 'bitvec'
ARRAY  = 'array'

OP_SORT = 'sort'

OP_ZERO = 'zero'
OP_ONE  = 'one'

OP_CONST  = 'const'
OP_CONSTD = 'constd'
OP_CONSTH = 'consth'
OP_INPUT  = 'input'
OP_STATE  = 'state'

OP_INIT  = 'init'
OP_NEXT  = 'next'

OP_SEXT  = 'sext'
OP_UEXT  = 'uext'
OP_SLICE = 'slice'

OP_NOT = 'not'
OP_INC = 'inc'
OP_DEC = 'dec'
OP_NEG = 'neg'

OP_IMPLIES = 'implies'
OP_EQ      = 'eq'
OP_NEQ     = 'neq'
OP_SGT     = 'sgt'
OP_UGT     = 'ugt'
OP_SGTE    = 'sgte'
OP_UGTE    = 'ugte'
OP_SLT     = 'slt'
OP_ULT     = 'ult'
OP_SLTE    = 'slte'
OP_ULTE    = 'ulte'

OP_AND = 'and'
OP_OR  = 'or'
OP_XOR = 'xor'

OP_SLL = 'sll'
OP_SRL = 'srl'
OP_SRA = 'sra'

OP_ADD  = 'add'
OP_SUB  = 'sub'
OP_MUL  = 'mul'
OP_SDIV = 'sdiv'
OP_UDIV = 'udiv'
OP_SREM = 'srem'
OP_UREM = 'urem'

OP_CONCAT = 'concat'
OP_READ   = 'read'

OP_ITE   = 'ite'
OP_WRITE = 'write'

OP_BAD        = 'bad'
OP_CONSTRAINT = 'constraint'

class model_error(Exception):
    def __init__(self, expected, line_no):
        super().__init__(f"model error in line {line_no}: {expected} expected")

class Z3():
    def __init__(self):
        self.z3 = None

class Bitwuzla():
    def __init__(self):
        self.bitwuzla = None

class Line(Z3, Bitwuzla):
    lines = dict()

    def __init__(self, nid, comment, line_no):
        Z3.__init__(self)
        Bitwuzla.__init__(self)
        self.nid = nid
        self.comment = "; " + comment if comment != "" and comment[0] != ';' else comment
        self.line_no = line_no
        self.new_line()

    def __repr__(self):
        return self.__str__()

    def new_line(self):
        assert self not in Line.lines
        Line.lines[self.nid] = self

    def is_defined(nid):
        return nid in Line.lines

    def get(nid):
        assert nid in Line.lines
        return Line.lines[nid]

class Sort(Line):
    keyword = OP_SORT

    def __init__(self, nid, comment, line_no):
        super().__init__(nid, comment, line_no)

    def match_sorts(self, sort):
        return type(self) == type(sort)

class Bitvector(Sort):
    keyword = BITVEC

    def __init__(self, nid, size, comment, line_no):
        super().__init__(nid, comment, line_no)
        self.size = size

    def __str__(self):
        return f"{self.nid} {Sort.keyword} {Bitvec.keyword} {self.size} {self.comment}"

    def match_init_sorts(self, sort):
        return self.match_sorts(sort)

class Bool(Bitvector):
    def __init__(self, nid, comment, line_no):
        super().__init__(nid, 1, comment, line_no)

    def match_sorts(self, sort):
        return super().match_sorts(sort)

    def get_z3(self):
        if self.z3 is None:
            self.z3 = z3.BoolSort()
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            self.bitwuzla = tm.mk_bool_sort()
        return self.bitwuzla

class Bitvec(Bitvector):
    def __init__(self, nid, size, comment, line_no):
        super().__init__(nid, size, comment, line_no)

    def match_sorts(self, sort):
        return super().match_sorts(sort) and self.size == sort.size

    def get_z3(self):
        if self.z3 is None:
            self.z3 = z3.BitVecSort(self.size)
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            self.bitwuzla = tm.mk_bv_sort(self.size)
        return self.bitwuzla

class Array(Sort):
    keyword = ARRAY

    def __init__(self, nid, array_size_line, element_size_line, comment, line_no):
        super().__init__(nid, comment, line_no)
        self.array_size_line = array_size_line
        self.element_size_line = element_size_line
        if not isinstance(array_size_line, Bitvec):
            raise model_error("array size bitvector", line_no)
        if not isinstance(element_size_line, Bitvec):
            raise model_error("element size bitvector", line_no)

    def __str__(self):
        return f"{self.nid} {Sort.keyword} {Array.keyword} {self.array_size_line.nid} {self.element_size_line.nid} {self.comment}"

    def match_sorts(self, sort):
        return (super().match_sorts(sort)
            and self.array_size_line.match_sorts(sort.array_size_line)
            and self.element_size_line.match_sorts(sort.element_size_line))

    def match_init_sorts(self, sort):
        # allow constant arrays: array init with bitvector
        return (self.match_sorts(sort)
            or (isinstance(sort, Bitvec) and self.element_size_line.match_sorts(sort)))

    def get_z3(self):
        if self.z3 is None:
            self.z3 = z3.ArraySort(self.array_size_line.get_z3(),
                self.element_size_line.get_z3())
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            self.bitwuzla = tm.mk_array_sort(self.array_size_line.get_bitwuzla(tm),
                self.element_size_line.get_bitwuzla(tm))
        return self.bitwuzla

class Expression(Line):
    def __init__(self, nid, sid_line, domain, comment, line_no):
        super().__init__(nid, comment, line_no)
        self.sid_line = sid_line
        self.domain = domain
        if not isinstance(sid_line, Sort):
            raise model_error("sort", line_no)

class Constant(Expression):
    def __init__(self, nid, sid_line, value, comment, line_no):
        super().__init__(nid, sid_line, dict(), comment, line_no)
        self.value = value
        if value >= 2**sid_line.size:
            raise model_error(f"{value} in range of {sid_line.size}-bit bitvector", line_no)

    def get_z3(self):
        if self.z3 is None:
            if isinstance(self.sid_line, Bool):
                self.z3 = z3.BoolVal(bool(self.value))
            else:
                self.z3 = z3.BitVecVal(self.value, self.sid_line.size)
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            if isinstance(self.sid_line, Bool):
                self.bitwuzla = tm.mk_true() if bool(self.value) else tm.mk_false()
            else:
                self.bitwuzla = tm.mk_bv_value(self.sid_line.get_bitwuzla(tm), self.value)
        return self.bitwuzla

class Zero(Constant):
    keyword = OP_ZERO

    def __init__(self, nid, sid_line, comment, line_no):
        super().__init__(nid, sid_line, 0, comment, line_no)

    def __str__(self):
        return f"{self.nid} {Zero.keyword} {self.sid_line.nid} {self.comment}"

class One(Constant):
    keyword = OP_ONE

    def __init__(self, nid, sid_line, comment, line_no):
        super().__init__(nid, sid_line, 1, comment, line_no)

    def __str__(self):
        return f"{self.nid} {One.keyword} {self.sid_line.nid} {self.comment}"

class Constd(Constant):
    keyword = OP_CONSTD

    def __init__(self, nid, sid_line, value, comment, line_no):
        super().__init__(nid, sid_line, value, comment, line_no)

    def __str__(self):
        return f"{self.nid} {Constd.keyword} {self.sid_line.nid} {self.value} {self.comment}"

class Const(Constant):
    keyword = OP_CONST

    def __init__(self, nid, sid_line, value, comment, line_no):
        super().__init__(nid, sid_line, value, comment, line_no)

    def __str__(self):
        size = self.sid_line.size
        return f"{self.nid} {Const.keyword} {self.sid_line.nid} {self.value:0{size}b} {self.comment}"

class Consth(Constant):
    keyword = OP_CONSTH

    def __init__(self, nid, sid_line, value, comment, line_no):
        super().__init__(nid, sid_line, value, comment, line_no)

    def __str__(self):
        size = math.ceil(self.sid_line.size / 4)
        return f"{self.nid} {Consth.keyword} {self.sid_line.nid} {self.value:0{size}X} {self.comment}"

class Variable(Expression):
    keywords = {OP_INPUT, OP_STATE}

    inputs = dict()

    def __init__(self, nid, sid_line, domain, symbol, comment, line_no):
        super().__init__(nid, sid_line, domain, comment, line_no)
        self.symbol = symbol

    def new_input(self):
        assert self not in Variable.inputs
        Variable.inputs[self.nid] = self

class Input(Variable):
    keyword = OP_INPUT

    def __init__(self, nid, sid_line, symbol, comment, line_no):
        super().__init__(nid, sid_line, dict(), symbol, comment, line_no)
        self.name = f"input{self.nid}"
        self.new_input()

    def __str__(self):
        return f"{self.nid} {Input.keyword} {self.sid_line.nid} {self.symbol} {self.comment}"

    def get_z3(self):
        if self.z3 is None:
            self.z3 = z3.Const(self.name, self.sid_line.get_z3())
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            self.bitwuzla = tm.mk_const(self.sid_line.get_bitwuzla(tm), self.name)
        return self.bitwuzla

class State(Variable):
    keyword = OP_STATE

    states = dict()

    pc = None

    def __init__(self, nid, sid_line, symbol, comment, line_no):
        super().__init__(nid, sid_line, {nid:self}, symbol, comment, line_no)
        self.name = f"state{nid}"
        self.init_line = self
        self.next_line = self
        self.step_z3 = 0
        self.current_z3 = None
        self.next_z3 = None
        self.step_bitwuzla = 0
        self.current_bitwuzla = None
        self.next_bitwuzla = None
        self.new_state()
        # rotor-dependent program counter declaration
        if comment == "; program counter":
            State.pc = self

    def __str__(self):
        return f"{self.nid} {State.keyword} {self.sid_line.nid} {self.symbol} {self.comment}"

    def new_state(self):
        assert self not in State.states
        State.states[self.nid] = self

    def get_z3(self):
        if self.z3 is None:
            self.z3 = z3.Const(self.name, self.sid_line.get_z3())
        return self.z3

    def get_z3_lambda(term, domain):
        if domain:
            return z3.Lambda([state.get_z3() for state in domain.values()], term)
        else:
            return term

    def get_step_name(self, step):
        return f"{self.name}-{step}"

    def get_z3_state(self, step):
        return z3.Const(self.get_step_name(step), self.sid_line.get_z3())

    def get_z3_step(self, step):
        assert self.step_z3 <= step <= self.step_z3 + 1
        if step == self.step_z3:
            if self.current_z3 is None:
                self.current_z3 = self.get_z3_state(step)
            return self.current_z3
        elif step == self.step_z3 + 1:
            if self.next_z3 is None:
                self.next_z3 = self.get_z3_state(step)
            return self.next_z3

    def get_z3_select(term, domain, step):
        if domain:
            return z3.Select(term, *[state.get_z3_step(step) for state in domain.values()])
        else:
            return term

    def take_z3_step(self):
        self.current_z3 = self.next_z3
        self.step_z3 += 1
        self.next_z3 = self.get_z3_state(self.step_z3 + 1)

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            self.bitwuzla = tm.mk_var(self.sid_line.get_bitwuzla(tm), self.name)
        return self.bitwuzla

    def get_bitwuzla_lambda(term, domain, tm):
        if domain:
            return tm.mk_term(bitwuzla.Kind.LAMBDA,
                [*[state.get_bitwuzla(tm) for state in domain.values()], term])
        else:
            return term

    def get_bitwuzla_state(self, step, tm):
        return tm.mk_const(self.sid_line.get_bitwuzla(tm), self.get_step_name(step))

    def get_bitwuzla_step(self, step, tm):
        assert self.step_bitwuzla <= step <= self.step_bitwuzla + 1
        if step == self.step_bitwuzla:
            if self.current_bitwuzla is None:
                self.current_bitwuzla = self.get_bitwuzla_state(step, tm)
            return self.current_bitwuzla
        elif step == self.step_bitwuzla + 1:
            if self.next_bitwuzla is None:
                self.next_bitwuzla = self.get_bitwuzla_state(step, tm)
            return self.next_bitwuzla

    def get_bitwuzla_select(term, domain, step, tm):
        if domain:
            return tm.mk_term(bitwuzla.Kind.APPLY,
                [term, *[state.get_bitwuzla_step(step, tm) for state in domain.values()]])
        else:
            return term

    def take_bitwuzla_step(self, tm):
        self.current_bitwuzla = self.next_bitwuzla
        self.step_bitwuzla += 1
        self.next_bitwuzla = self.get_bitwuzla_state(self.step_bitwuzla + 1, tm)

class Indexed(Expression):
    def __init__(self, nid, sid_line, arg1_line, comment, line_no):
        super().__init__(nid, sid_line, arg1_line.domain, comment, line_no)
        self.arg1_line = arg1_line
        if not isinstance(arg1_line, Expression):
            raise model_error("expression operand", line_no)
        if not isinstance(sid_line, Bitvec):
            raise model_error("bitvector result", line_no)
        if not isinstance(arg1_line.sid_line, Bitvec):
            raise model_error("bitvector operand", line_no)

class Ext(Indexed):
    keywords = {OP_SEXT, OP_UEXT}

    def __init__(self, nid, op, sid_line, arg1_line, w, comment, line_no):
        super().__init__(nid, sid_line, arg1_line, comment, line_no)
        self.op = op
        self.w = w
        if sid_line.size != arg1_line.sid_line.size + w:
            raise model_error("compatible bitvector sorts", line_no)

    def __str__(self):
        return f"{self.nid} {self.op} {self.sid_line.nid} {self.arg1_line.nid} {self.w} {self.comment}"

    def get_z3(self):
        if self.z3 is None:
            if self.op == 'sext':
                self.z3 = z3.SignExt(self.w, self.arg1_line.get_z3())
            elif self.op == 'uext':
                self.z3 = z3.ZeroExt(self.w, self.arg1_line.get_z3())
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            if self.op == 'sext':
                bitwuzla_op = bitwuzla.Kind.BV_SIGN_EXTEND
            elif self.op == 'uext':
                bitwuzla_op = bitwuzla.Kind.BV_ZERO_EXTEND
            self.bitwuzla = tm.mk_term(bitwuzla_op,
                [self.arg1_line.get_bitwuzla(tm)], [self.w])
        return self.bitwuzla

class Slice(Indexed):
    keyword = OP_SLICE

    def __init__(self, nid, sid_line, arg1_line, u, l, comment, line_no):
        super().__init__(nid, sid_line, arg1_line, comment, line_no)
        self.u = u
        self.l = l
        if u >= arg1_line.sid_line.size:
            raise model_error("upper bit in range", line_no)
        if u < l:
            raise model_error("upper bit >= lower bit", line_no)
        if sid_line.size != u - l + 1:
            raise model_error("compatible bitvector sorts", line_no)

    def __str__(self):
        return f"{self.nid} {Slice.keyword} {self.sid_line.nid} {self.arg1_line.nid} {self.u} {self.l} {self.comment}"

    def get_z3(self):
        if self.z3 is None:
            self.z3 = z3.Extract(self.u, self.l, self.arg1_line.get_z3())
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            self.bitwuzla = tm.mk_term(bitwuzla.Kind.BV_EXTRACT,
                [self.arg1_line.get_bitwuzla(tm)], [self.u, self.l])
        return self.bitwuzla

class Unary(Expression):
    keywords = {OP_NOT, OP_INC, OP_DEC, OP_NEG}

    def __init__(self, nid, op, sid_line, arg1_line, comment, line_no):
        super().__init__(nid, sid_line, arg1_line.domain, comment, line_no)
        self.op = op
        self.arg1_line = arg1_line
        if not isinstance(arg1_line, Expression):
            raise model_error("expression operand", line_no)
        if op == 'not' and not isinstance(sid_line, Bitvector):
            raise model_error("Boolean or bitvector result", line_no)
        if op != 'not' and not isinstance(sid_line, Bitvec):
            raise model_error("bitvector result", line_no)
        if not sid_line.match_sorts(arg1_line.sid_line):
            raise model_error("compatible sorts", line_no)

    def __str__(self):
        return f"{self.nid} {self.op} {self.sid_line.nid} {self.arg1_line.nid} {self.comment}"

    def get_z3(self):
        if self.z3 is None:
            if self.op == 'not':
                if isinstance(self.sid_line, Bool):
                    self.z3 = z3.Not(self.arg1_line.get_z3())
                else:
                    self.z3 = ~self.arg1_line.get_z3()
            elif self.op == 'inc':
                self.z3 = self.arg1_line.get_z3() + 1
            elif self.op == 'dec':
                self.z3 = self.arg1_line.get_z3() - 1
            elif self.op == 'neg':
                self.z3 = -self.arg1_line.get_z3()
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            if self.op == 'not':
                if isinstance(self.sid_line, Bool):
                    bitwuzla_op = bitwuzla.Kind.NOT
                else:
                    bitwuzla_op = bitwuzla.Kind.BV_NOT
            elif self.op == 'inc':
                bitwuzla_op = bitwuzla.Kind.BV_INC
            elif self.op == 'dec':
                bitwuzla_op = bitwuzla.Kind.BV_DEC
            elif self.op == 'neg':
                bitwuzla_op = bitwuzla.Kind.BV_NEG
            self.bitwuzla = tm.mk_term(bitwuzla_op, [self.arg1_line.get_bitwuzla(tm)])
        return self.bitwuzla

class Binary(Expression):
    keywords = {OP_IMPLIES, OP_EQ, OP_NEQ, OP_SGT, OP_UGT, OP_SGTE, OP_UGTE, OP_SLT, OP_ULT, OP_SLTE, OP_ULTE, OP_AND, OP_OR, OP_XOR, OP_SLL, OP_SRL, OP_SRA, OP_ADD, OP_SUB, OP_MUL, OP_SDIV, OP_UDIV, OP_SREM, OP_UREM, OP_CONCAT, OP_READ}

    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        super().__init__(nid, sid_line, arg1_line.domain | arg2_line.domain, comment, line_no)
        self.op = op
        self.arg1_line = arg1_line
        self.arg2_line = arg2_line
        if not isinstance(arg1_line, Expression):
            raise model_error("expression left operand", line_no)
        if not isinstance(arg2_line, Expression):
            raise model_error("expression right operand", line_no)

    def __str__(self):
        return f"{self.nid} {self.op} {self.sid_line.nid} {self.arg1_line.nid} {self.arg2_line.nid} {self.comment}"

class Implies(Binary):
    keyword = OP_IMPLIES

    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        super().__init__(nid, Implies.keyword, sid_line, arg1_line, arg2_line, comment, line_no)
        if not isinstance(sid_line, Bool):
            raise model_error("Boolean result", line_no)
        if not sid_line.match_sorts(arg1_line.sid_line):
            raise model_error("compatible result and first operand sorts", line_no)
        if not arg1_line.sid_line.match_sorts(arg2_line.sid_line):
            raise model_error("compatible first and second operand sorts", line_no)

    def get_z3(self):
        if self.z3 is None:
            self.z3 = z3.Implies(self.arg1_line.get_z3(), self.arg2_line.get_z3())
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            self.bitwuzla = tm.mk_term(bitwuzla.Kind.IMPLIES,
                [self.arg1_line.get_bitwuzla(tm), self.arg2_line.get_bitwuzla(tm)])
        return self.bitwuzla

class Comparison(Binary):
    keywords = {OP_EQ, OP_NEQ, OP_SGT, OP_UGT, OP_SGTE, OP_UGTE, OP_SLT, OP_ULT, OP_SLTE, OP_ULTE}

    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        super().__init__(nid, op, sid_line, arg1_line, arg2_line, comment, line_no)
        if not isinstance(sid_line, Bool):
            raise model_error("Boolean result", line_no)
        if not isinstance(arg1_line.sid_line, Bitvec):
            raise model_error("bitvector first operand", line_no)
        if not arg1_line.sid_line.match_sorts(arg2_line.sid_line):
            raise model_error("compatible first and second operand sorts", line_no)

    def get_z3(self):
        if self.z3 is None:
            if self.op == 'eq':
                self.z3 = self.arg1_line.get_z3() == self.arg2_line.get_z3()
            elif self.op == 'neq':
                self.z3 = self.arg1_line.get_z3() != self.arg2_line.get_z3()
            elif self.op == 'sgt':
                self.z3 = self.arg1_line.get_z3() > self.arg2_line.get_z3()
            elif self.op == 'ugt':
                self.z3 = z3.UGT(self.arg1_line.get_z3(), self.arg2_line.get_z3())
            elif self.op == 'sgte':
                self.z3 = self.arg1_line.get_z3() >= self.arg2_line.get_z3()
            elif self.op == 'ugte':
                self.z3 = z3.UGE(self.arg1_line.get_z3(), self.arg2_line.get_z3())
            elif self.op == 'slt':
                self.z3 = self.arg1_line.get_z3() < self.arg2_line.get_z3()
            elif self.op == 'ult':
                self.z3 = z3.ULT(self.arg1_line.get_z3(), self.arg2_line.get_z3())
            elif self.op == 'slte':
                self.z3 = self.arg1_line.get_z3() <= self.arg2_line.get_z3()
            elif self.op == 'ulte':
                self.z3 = z3.ULE(self.arg1_line.get_z3(), self.arg2_line.get_z3())
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            if self.op == 'eq':
                bitwuzla_op = bitwuzla.Kind.EQUAL
            elif self.op == 'neq':
                bitwuzla_op = bitwuzla.Kind.DISTINCT
            elif self.op == 'sgt':
                bitwuzla_op = bitwuzla.Kind.BV_SGT
            elif self.op == 'ugt':
                bitwuzla_op = bitwuzla.Kind.BV_UGT
            elif self.op == 'sgte':
                bitwuzla_op = bitwuzla.Kind.BV_SGE
            elif self.op == 'ugte':
                bitwuzla_op = bitwuzla.Kind.BV_UGE
            elif self.op == 'slt':
                bitwuzla_op = bitwuzla.Kind.BV_SLT
            elif self.op == 'ult':
                bitwuzla_op = bitwuzla.Kind.BV_ULT
            elif self.op == 'slte':
                bitwuzla_op = bitwuzla.Kind.BV_SLE
            elif self.op == 'ulte':
                bitwuzla_op = bitwuzla.Kind.BV_ULE
            self.bitwuzla = tm.mk_term(bitwuzla_op,
                [self.arg1_line.get_bitwuzla(tm), self.arg2_line.get_bitwuzla(tm)])
        return self.bitwuzla

class Logical(Binary):
    keywords = {OP_AND, OP_OR, OP_XOR}

    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        super().__init__(nid, op, sid_line, arg1_line, arg2_line, comment, line_no)
        if not isinstance(sid_line, Bitvector):
            raise model_error("Boolean or bitvector result", line_no)
        if not sid_line.match_sorts(arg1_line.sid_line):
            raise model_error("compatible result and first operand sorts", line_no)
        if not arg1_line.sid_line.match_sorts(arg2_line.sid_line):
            raise model_error("compatible first and second operand sorts", line_no)

    def get_z3(self):
        if self.z3 is None:
            if isinstance(self.sid_line, Bool):
                if self.op == 'and':
                    self.z3 = z3.And(self.arg1_line.get_z3(), self.arg2_line.get_z3())
                elif self.op == 'or':
                    self.z3 = z3.Or(self.arg1_line.get_z3(), self.arg2_line.get_z3())
                elif self.op == 'xor':
                    self.z3 = z3.Xor(self.arg1_line.get_z3(), self.arg2_line.get_z3())
            else:
                if self.op == 'and':
                    self.z3 = self.arg1_line.get_z3() & self.arg2_line.get_z3()
                elif self.op == 'or':
                    self.z3 = self.arg1_line.get_z3() | self.arg2_line.get_z3()
                elif self.op == 'xor':
                    self.z3 = self.arg1_line.get_z3() ^ self.arg2_line.get_z3()
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            if isinstance(self.sid_line, Bool):
                if self.op == 'and':
                    bitwuzla_op = bitwuzla.Kind.AND
                elif self.op == 'or':
                    bitwuzla_op = bitwuzla.Kind.OR
                elif self.op == 'xor':
                    bitwuzla_op = bitwuzla.Kind.XOR
            else:
                if self.op == 'and':
                    bitwuzla_op = bitwuzla.Kind.BV_AND
                elif self.op == 'or':
                    bitwuzla_op = bitwuzla.Kind.BV_OR
                elif self.op == 'xor':
                    bitwuzla_op = bitwuzla.Kind.BV_XOR
            self.bitwuzla = tm.mk_term(bitwuzla_op,
                [self.arg1_line.get_bitwuzla(tm), self.arg2_line.get_bitwuzla(tm)])
        return self.bitwuzla

class Computation(Binary):
    keywords = {OP_SLL, OP_SRL, OP_SRA, OP_ADD, OP_SUB, OP_MUL, OP_SDIV, OP_UDIV, OP_SREM, OP_UREM}

    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        super().__init__(nid, op, sid_line, arg1_line, arg2_line, comment, line_no)
        if not isinstance(sid_line, Bitvec):
            raise model_error("bitvector result", line_no)
        if not sid_line.match_sorts(arg1_line.sid_line):
            raise model_error("compatible result and first operand sorts", line_no)
        if not arg1_line.sid_line.match_sorts(arg2_line.sid_line):
            raise model_error("compatible first and second operand sorts", line_no)

    def get_z3(self):
        if self.z3 is None:
            if self.op == 'sll':
                self.z3 = self.arg1_line.get_z3() << self.arg2_line.get_z3()
            elif self.op == 'srl':
                self.z3 = z3.LShR(self.arg1_line.get_z3(), self.arg2_line.get_z3())
            elif self.op == 'sra':
                self.z3 = self.arg1_line.get_z3() >> self.arg2_line.get_z3()
            elif self.op == 'add':
                self.z3 = self.arg1_line.get_z3() + self.arg2_line.get_z3()
            elif self.op == 'sub':
                self.z3 = self.arg1_line.get_z3() - self.arg2_line.get_z3()
            elif self.op == 'mul':
                self.z3 = self.arg1_line.get_z3() * self.arg2_line.get_z3()
            elif self.op == 'sdiv':
                self.z3 = self.arg1_line.get_z3() / self.arg2_line.get_z3()
            elif self.op == 'udiv':
                self.z3 = z3.UDiv(self.arg1_line.get_z3(), self.arg2_line.get_z3())
            elif self.op == 'srem':
                self.z3 = z3.SRem(self.arg1_line.get_z3(), self.arg2_line.get_z3())
            elif self.op == 'urem':
                self.z3 = z3.URem(self.arg1_line.get_z3(), self.arg2_line.get_z3())
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            if self.op == 'sll':
                bitwuzla_op = bitwuzla.Kind.BV_SHL
            elif self.op == 'srl':
                bitwuzla_op = bitwuzla.Kind.BV_SHR
            elif self.op == 'sra':
                bitwuzla_op = bitwuzla.Kind.BV_ASHR
            elif self.op == 'add':
                bitwuzla_op = bitwuzla.Kind.BV_ADD
            elif self.op == 'sub':
                bitwuzla_op = bitwuzla.Kind.BV_SUB
            elif self.op == 'mul':
                bitwuzla_op = bitwuzla.Kind.BV_MUL
            elif self.op == 'sdiv':
                bitwuzla_op = bitwuzla.Kind.BV_SDIV
            elif self.op == 'udiv':
                bitwuzla_op = bitwuzla.Kind.BV_UDIV
            elif self.op == 'srem':
                bitwuzla_op = bitwuzla.Kind.BV_SREM
            elif self.op == 'urem':
                bitwuzla_op = bitwuzla.Kind.BV_UREM
            self.bitwuzla = tm.mk_term(bitwuzla_op,
                [self.arg1_line.get_bitwuzla(tm), self.arg2_line.get_bitwuzla(tm)])
        return self.bitwuzla

class Concat(Binary):
    keyword = OP_CONCAT

    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        super().__init__(nid, Concat.keyword, sid_line, arg1_line, arg2_line, comment, line_no)
        if not isinstance(sid_line, Bitvec):
            raise model_error("bitvector result", line_no)
        if not isinstance(arg1_line.sid_line, Bitvec):
            raise model_error("bitvector first operand", line_no)
        if not isinstance(arg2_line.sid_line, Bitvec):
            raise model_error("bitvector second operand", line_no)
        if sid_line.size != arg1_line.sid_line.size + arg2_line.sid_line.size:
            raise model_error("compatible bitvector result", line_no)

    def get_z3(self):
        if self.z3 is None:
            self.z3 = z3.Concat(self.arg1_line.get_z3(), self.arg2_line.get_z3())
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            self.bitwuzla = tm.mk_term(bitwuzla.Kind.BV_CONCAT,
                [self.arg1_line.get_bitwuzla(tm), self.arg2_line.get_bitwuzla(tm)])
        return self.bitwuzla

class Read(Binary):
    keyword = OP_READ

    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, comment, line_no):
        super().__init__(nid, Read.keyword, sid_line, arg1_line, arg2_line, comment, line_no)
        if not isinstance(arg1_line.sid_line, Array):
            raise model_error("array first operand", line_no)
        if not arg1_line.sid_line.array_size_line.match_sorts(arg2_line.sid_line):
            raise model_error("compatible first operand array size and second operand sorts", line_no)
        if not sid_line.match_sorts(arg1_line.sid_line.element_size_line):
            raise model_error("compatible result and first operand element size sorts", line_no)

    def get_z3(self):
        if self.z3 is None:
            self.z3 = z3.Select(self.arg1_line.get_z3(), self.arg2_line.get_z3())
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            self.bitwuzla = tm.mk_term(bitwuzla.Kind.ARRAY_SELECT,
                [self.arg1_line.get_bitwuzla(tm), self.arg2_line.get_bitwuzla(tm)])
        return self.bitwuzla

class Ternary(Expression):
    keywords = {OP_ITE, OP_WRITE}

    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, arg3_line, comment, line_no):
        super().__init__(nid, sid_line, arg1_line.domain | arg2_line.domain | arg3_line.domain, comment, line_no)
        self.op = op
        self.arg1_line = arg1_line
        self.arg2_line = arg2_line
        self.arg3_line = arg3_line
        if not isinstance(arg1_line, Expression):
            raise model_error("expression first operand", line_no)
        if not isinstance(arg2_line, Expression):
            raise model_error("expression second operand", line_no)
        if not isinstance(arg3_line, Expression):
            raise model_error("expression third operand", line_no)

    def __str__(self):
        return f"{self.nid} {self.op} {self.sid_line.nid} {self.arg1_line.nid} {self.arg2_line.nid} {self.arg3_line.nid} {self.comment}"

class Ite(Ternary):
    keyword = OP_ITE

    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, arg3_line, comment, line_no):
        super().__init__(nid, Ite.keyword, sid_line, arg1_line, arg2_line, arg3_line, comment, line_no)
        if not isinstance(arg1_line.sid_line, Bool):
            raise model_error("Boolean first operand", line_no)
        if not sid_line.match_sorts(arg2_line.sid_line):
            raise model_error("compatible result and second operand sorts", line_no)
        if not arg2_line.sid_line.match_sorts(arg3_line.sid_line):
            raise model_error("compatible second and third operand sorts", line_no)

    def get_z3(self):
        if self.z3 is None:
            self.z3 = z3.If(self.arg1_line.get_z3(),
                self.arg2_line.get_z3(), self.arg3_line.get_z3())
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            self.bitwuzla = tm.mk_term(bitwuzla.Kind.ITE,
                [self.arg1_line.get_bitwuzla(tm),
                self.arg2_line.get_bitwuzla(tm),
                self.arg3_line.get_bitwuzla(tm)])
        return self.bitwuzla

class Write(Ternary):
    keyword = OP_WRITE

    def __init__(self, nid, op, sid_line, arg1_line, arg2_line, arg3_line, comment, line_no):
        super().__init__(nid, Write.keyword, sid_line, arg1_line, arg2_line, arg3_line, comment, line_no)
        if not isinstance(sid_line, Array):
            raise model_error("array result", line_no)
        if not sid_line.match_sorts(arg1_line.sid_line):
            raise model_error("compatible result and first operand sorts", line_no)
        if not arg1_line.sid_line.array_size_line.match_sorts(arg2_line.sid_line):
            raise model_error("compatible first operand array size and second operand sorts", line_no)
        if not arg1_line.sid_line.element_size_line.match_sorts(arg3_line.sid_line):
            raise model_error("compatible first operand element size and third operand sorts", line_no)

    def get_z3(self):
        if self.z3 is None:
            self.z3 = z3.Store(self.arg1_line.get_z3(),
                self.arg2_line.get_z3(), self.arg3_line.get_z3())
        return self.z3

    def get_bitwuzla(self, tm):
        if self.bitwuzla is None:
            self.bitwuzla = tm.mk_term(bitwuzla.Kind.ARRAY_STORE,
                [self.arg1_line.get_bitwuzla(tm),
                self.arg2_line.get_bitwuzla(tm),
                self.arg3_line.get_bitwuzla(tm)])
        return self.bitwuzla

class Sequential(Line):
    def __init__(self, nid, exp_line, comment, line_no):
        super().__init__(nid, comment, line_no)
        self.exp_line = exp_line
        self.step_z3 = 0
        self.z3_lambda_line = None
        self.step_bitwuzla = 0
        self.bitwuzla_lambda_line = None
        if not isinstance(exp_line, Expression):
            raise model_error("expression operand", line_no)

class Init(Sequential):
    keyword = OP_INIT

    inits = dict()

    def __init__(self, nid, sid_line, state_line, exp_line, comment, line_no):
        super().__init__(nid, exp_line, comment, line_no)
        self.sid_line = sid_line
        self.state_line = state_line
        if not isinstance(sid_line, Sort):
            raise model_error("sort", line_no)
        if not isinstance(state_line, State):
            raise model_error("state operand", line_no)
        if not self.sid_line.match_sorts(state_line.sid_line):
            raise model_error("compatible line and state sorts", line_no)
        if not state_line.sid_line.match_init_sorts(exp_line.sid_line):
            raise model_error("compatible state and expression sorts", line_no)
        if state_line.nid < exp_line.nid:
            raise model_error("state after expression", line_no)
        if self.state_line.init_line == self.state_line:
            self.state_line.init_line = self
        else:
            raise model_error("uninitialized state", line_no)
        self.new_init()

    def __str__(self):
        return f"{self.nid} {Init.keyword} {self.sid_line.nid} {self.state_line.nid} {self.exp_line.nid} {self.comment}"

    def new_init(self):
        assert self not in Init.inits
        Init.inits[self.nid] = self

    def get_z3_step(self, step):
        assert step == 0
        if isinstance(self.sid_line, Array) and isinstance(self.exp_line.sid_line, Bitvec):
            # initialize with constant array
            return self.state_line.get_z3_step(0) == z3.K(
                self.sid_line.array_size_line.get_z3(),
                self.exp_line.get_z3())
        else:
            return self.state_line.get_z3_step(0) == State.get_z3_select(
                State.get_z3_lambda(self.exp_line.get_z3(), self.exp_line.domain),
                self.exp_line.domain, 0)

    def get_bitwuzla_step(self, step, tm):
        assert step == 0
        if isinstance(self.sid_line, Array) and isinstance(self.exp_line.sid_line, Bitvec):
            # initialize with constant array
            return tm.mk_term(bitwuzla.Kind.EQUAL,
                [self.state_line.get_bitwuzla_step(0, tm),
                tm.mk_const_array(self.sid_line.get_bitwuzla(tm),
                    self.exp_line.get_bitwuzla(tm))])
        else:
            return tm.mk_term(bitwuzla.Kind.EQUAL,
                [self.state_line.get_bitwuzla_step(0, tm),
                State.get_bitwuzla_select(
                    State.get_bitwuzla_lambda(
                        self.exp_line.get_bitwuzla(tm), self.exp_line.domain, tm),
                    self.exp_line.domain, 0, tm)])

class Next(Sequential):
    keyword = OP_NEXT

    nexts = dict()

    def __init__(self, nid, sid_line, state_line, exp_line, comment, line_no):
        super().__init__(nid, exp_line, comment, line_no)
        self.sid_line = sid_line
        self.state_line = state_line
        if not isinstance(sid_line, Sort):
            raise model_error("sort", line_no)
        if not isinstance(state_line, State):
            raise model_error("state operand", line_no)
        if not self.sid_line.match_sorts(state_line.sid_line):
            raise model_error("compatible line and state sorts", line_no)
        if not state_line.sid_line.match_sorts(exp_line.sid_line):
            raise model_error("compatible state and expression sorts", line_no)
        if self.state_line.next_line == self.state_line:
            self.state_line.next_line = self
        else:
            raise model_error("untransitioned state", line_no)
        self.new_next()

    def __str__(self):
        return f"{self.nid} {Next.keyword} {self.sid_line.nid} {self.state_line.nid} {self.exp_line.nid} {self.comment}"

    def new_next(self):
        assert self not in Next.nexts
        Next.nexts[self.nid] = self

    def get_z3_step(self, step):
        if self.z3_lambda_line is None:
            self.z3_lambda_line = State.get_z3_lambda(
                self.exp_line.get_z3(), self.exp_line.domain)
        assert step == self.step_z3
        self.step_z3 = step + 1
        return self.state_line.get_z3_step(step + 1) == State.get_z3_select(
            self.z3_lambda_line, self.exp_line.domain, step)

    def get_z3_change(self, step):
        assert step == self.step_z3 - 1
        return self.state_line.get_z3_step(step + 1) != self.state_line.get_z3_step(step)

    def get_bitwuzla_step(self, step, tm):
        if self.bitwuzla_lambda_line is None:
            self.bitwuzla_lambda_line = State.get_bitwuzla_lambda(
                self.exp_line.get_bitwuzla(tm), self.exp_line.domain, tm)
        assert step == self.step_bitwuzla
        self.step_bitwuzla = step + 1
        return tm.mk_term(bitwuzla.Kind.EQUAL,
            [self.state_line.get_bitwuzla_step(step + 1, tm),
            State.get_bitwuzla_select(self.bitwuzla_lambda_line, self.exp_line.domain, step, tm)])

    def get_bitwuzla_change(self, step, tm):
        assert step == self.step_bitwuzla - 1
        return tm.mk_term(bitwuzla.Kind.DISTINCT,
            [self.state_line.get_bitwuzla_step(step + 1, tm),
            self.state_line.get_bitwuzla_step(step, tm)])

class Property(Sequential):
    keywords = {OP_CONSTRAINT, OP_BAD}

    def __init__(self, nid, property_line, symbol, comment, line_no):
        super().__init__(nid, property_line, comment, line_no)
        self.symbol = symbol
        if not isinstance(property_line.sid_line, Bool):
            raise model_error("Boolean operand", line_no)

    def get_z3_step(self, step):
        if self.z3_lambda_line is None:
            self.z3_lambda_line = State.get_z3_lambda(
                self.exp_line.get_z3(), self.exp_line.domain)
        assert self.step_z3 <= step <= self.step_z3 + 1
        if (step == self.step_z3 and self.z3 is None) or step == self.step_z3 + 1:
            self.z3 = State.get_z3_select(self.z3_lambda_line, self.exp_line.domain, step)
        self.step_z3 = step
        return self.z3

    def get_bitwuzla_step(self, step, tm):
        if self.bitwuzla_lambda_line is None:
            self.bitwuzla_lambda_line = State.get_bitwuzla_lambda(
                self.exp_line.get_bitwuzla(tm), self.exp_line.domain, tm)
        assert self.step_bitwuzla <= step <= self.step_bitwuzla + 1
        if (step == self.step_bitwuzla and self.bitwuzla is None) or step == self.step_bitwuzla + 1:
            self.bitwuzla = State.get_bitwuzla_select(
                self.bitwuzla_lambda_line, self.exp_line.domain, step, tm)
        self.step_bitwuzla = step
        return self.bitwuzla

class Constraint(Property):
    keyword = OP_CONSTRAINT

    constraints = dict()

    def __init__(self, nid, property_line, symbol, comment, line_no):
        super().__init__(nid, property_line, symbol, comment, line_no)
        self.new_constraint()

    def __str__(self):
        return f"{self.nid} {Constraint.keyword} {self.exp_line.nid} {self.symbol} {self.comment}"

    def new_constraint(self):
        assert self not in Constraint.constraints
        Constraint.constraints[self.nid] = self

class Bad(Property):
    keyword = OP_BAD

    bads = dict()

    def __init__(self, nid, property_line, symbol, comment, line_no):
        super().__init__(nid, property_line, symbol, comment, line_no)
        self.new_bad()

    def __str__(self):
        return f"{self.nid} {Bad.keyword} {self.exp_line.nid} {self.symbol} {self.comment}"

    def new_bad(self):
        assert self not in Bad.bads
        Bad.bads[self.nid] = self

def get_class(keyword):
    if keyword == Zero.keyword:
        return Zero
    elif keyword == One.keyword:
        return One
    elif keyword == Constd.keyword:
        return Constd
    elif keyword == Const.keyword:
        return Const
    elif keyword == Consth.keyword:
        return Consth
    elif keyword == Input.keyword:
        return Input
    elif keyword == State.keyword:
        return State
    elif keyword in Ext.keywords:
        return Ext
    elif keyword == Slice.keyword:
        return Slice
    elif keyword in Unary.keywords:
        return Unary
    elif keyword == Implies.keyword:
        return Implies
    elif keyword in Comparison.keywords:
        return Comparison
    elif keyword in Logical.keywords:
        return Logical
    elif keyword in Computation.keywords:
        return Computation
    elif keyword == Concat.keyword:
        return Concat
    elif keyword == Read.keyword:
        return Read
    elif keyword == Ite.keyword:
        return Ite
    elif keyword == Write.keyword:
        return Write
    elif keyword == Init.keyword:
        return Init
    elif keyword == Next.keyword:
        return Next
    elif keyword == Constraint.keyword:
        return Constraint
    elif keyword == Bad.keyword:
        return Bad

current_nid = 0

def next_nid():
    global current_nid
    current_nid += 1
    return current_nid

def new_boolean(nid = next_nid(), line_no = None):
    return Bool(nid, "Boolean", line_no)

def new_bitvec(size_in_bits, comment, nid = next_nid(), line_no = None):
    return Bitvec(nid, size_in_bits, comment, line_no)

def new_array(address_sid, element_sid, comment, nid = next_nid(), line_no = None):
    return Array(nid, address_sid, element_sid, comment, line_no)

def new_zero_one(op, sid, comment, nid = next_nid(), line_no = None):
    assert op in {OP_ZERO, OP_ONE}
    return get_class(op)(nid, sid, comment, line_no)

def new_constant(op, sid, constant, comment, nid = next_nid(), line_no = None):
    assert op in {OP_CONSTD, OP_CONST, OP_CONSTH}
    if op == OP_CONSTD:
        if constant == 0:
            return Zero(nid, sid, comment, line_no)
        elif constant == 1:
            return One(nid, sid, comment, line_no)
    return get_class(op)(nid, sid, constant, comment, line_no)

def new_input(op, sid, symbol, comment, nid = next_nid(), line_no = None):
    assert op in Variable.keywords
    return get_class(op)(nid, sid, symbol, comment, line_no)

def new_ext(op, sid, value_nid, w, comment, nid = next_nid(), line_no = None):
    assert op in Ext.keywords
    return get_class(op)(nid, op, sid, value_nid, w, comment, line_no)

def new_slice(sid, value_nid, u, l, comment, nid = next_nid(), line_no = None):
    return Slice(nid, sid, value_nid, u, l, comment, line_no)

def new_unary(op, sid, value_nid, comment, nid = next_nid(), line_no = None):
    assert op in Unary.keywords
    return get_class(op)(nid, op, sid, value_nid, comment, line_no)

def new_unary_boolean(op, value_nid, comment, nid = next_nid(), line_no = None):
    assert op == OP_NOT
    return get_class(op)(nid, op, SID_BOOLEAN, value_nid, comment, line_no)

def new_binary(op, sid, left_nid, right_nid, comment, nid = next_nid(), line_no = None):
    assert op in Binary.keywords
    return get_class(op)(nid, op, sid, left_nid, right_nid, comment, line_no)

def new_binary_boolean(op, left_nid, right_nid, comment, nid = next_nid(), line_no = None):
    assert op in Implies.keyword + Comparison.keywords + Logical.keywords
    return get_class(op)(nid, op, SID_BOOLEAN, left_nid, right_nid, comment, line_no)

def new_ternary(op, sid, first_nid, second_nid, third_nid, comment, nid = next_nid(), line_no = None):
    assert op in Ternary.keywords
    return get_class(op)(nid, op, sid, first_nid, second_nid, third_nid, comment, line_no)

def new_init(sid, state_nid, value_nid, comment, nid = next_nid(), line_no = None):
    return Init(nid, sid, state_nid, value_nid, comment, line_no)

def new_next(sid, state_nid, value_nid, comment, nid = next_nid(), line_no = None):
    return Next(nid, sid, state_nid, value_nid, comment, line_no)

def new_init_next(op, sid, state_nid, value_nid, comment, nid = next_nid(), line_no = None):
    return get_class(op)(nid, sid, state_nid, value_nid, comment, line_no)

def new_property(op, condition_nid, symbol, comment, nid = next_nid(), line_no = None):
    assert op in Property.keywords
    return get_class(op)(nid, condition_nid, symbol, comment, line_no)

# RISC-V model generator

IS64BITTARGET = True # TODO: configure

WORDSIZEINBITS = 64 # TODO: define accordingly

# machine interface

SID_BOOLEAN = None

NID_FALSE = None
NID_TRUE  = None

SID_BYTE = None

NID_BYTE_0 = None
NID_BYTE_3 = None

HALFWORDSIZEINBITS = 16

SID_HALF_WORD = None

NID_HALF_WORD_0 = None
NID_HALF_WORD_1 = None

SINGLEWORDSIZEINBITS = 32

SID_SINGLE_WORD = None

NID_SINGLE_WORD_0 = None
NID_SINGLE_WORD_1 = None
NID_SINGLE_WORD_2 = None
NID_SINGLE_WORD_3 = None
NID_SINGLE_WORD_4 = None
NID_SINGLE_WORD_5 = None
NID_SINGLE_WORD_6 = None
NID_SINGLE_WORD_7 = None
NID_SINGLE_WORD_8 = None

NID_SINGLE_WORD_MINUS_1 = None
NID_SINGLE_WORD_INT_MIN = None

DOUBLEWORDSIZE = 8
DOUBLEWORDSIZEINBITS = 64

SID_DOUBLE_WORD = None

NID_DOUBLE_WORD_0 = None
NID_DOUBLE_WORD_1 = None
NID_DOUBLE_WORD_2 = None
NID_DOUBLE_WORD_3 = None
NID_DOUBLE_WORD_4 = None
NID_DOUBLE_WORD_5 = None
NID_DOUBLE_WORD_6 = None
NID_DOUBLE_WORD_7 = None
NID_DOUBLE_WORD_8 = None

NID_DOUBLE_WORD_MINUS_1 = None
NID_DOUBLE_WORD_INT_MIN = None

SID_MACHINE_WORD = None

NID_MACHINE_WORD_0 = None
NID_MACHINE_WORD_1 = None
NID_MACHINE_WORD_2 = None
NID_MACHINE_WORD_3 = None
NID_MACHINE_WORD_4 = None
NID_MACHINE_WORD_5 = None
NID_MACHINE_WORD_6 = None
NID_MACHINE_WORD_7 = None
NID_MACHINE_WORD_8 = None

NID_MACHINE_WORD_MINUS_1 = None
NID_MACHINE_WORD_INT_MIN = None

NID_LSB_MASK = None

SID_DOUBLE_MACHINE_WORD = None

def init_machine_interface():
    global SID_BOOLEAN, NID_FALSE, NID_TRUE

    global SID_BYTE, NID_BYTE_0, NID_BYTE_3

    global SID_HALF_WORD, NID_HALF_WORD_0, NID_HALF_WORD_1

    global SID_SINGLE_WORD, NID_SINGLE_WORD_0, NID_SINGLE_WORD_1, NID_SINGLE_WORD_2
    global NID_SINGLE_WORD_3, NID_SINGLE_WORD_4, NID_SINGLE_WORD_5, NID_SINGLE_WORD_6
    global NID_SINGLE_WORD_7, NID_SINGLE_WORD_8, NID_SINGLE_WORD_MINUS_1, NID_SINGLE_WORD_INT_MIN

    global SID_DOUBLE_WORD, DOUBLEWORDSIZEINBITS, NID_DOUBLE_WORD_0, NID_DOUBLE_WORD_1
    global NID_DOUBLE_WORD_2, NID_DOUBLE_WORD_3, NID_DOUBLE_WORD_4, NID_DOUBLE_WORD_5
    global NID_DOUBLE_WORD_6, NID_DOUBLE_WORD_7, NID_DOUBLE_WORD_8, NID_DOUBLE_WORD_MINUS_1
    global NID_DOUBLE_WORD_INT_MIN

    global SID_MACHINE_WORD, NID_MACHINE_WORD_0, NID_MACHINE_WORD_1, NID_MACHINE_WORD_2
    global NID_MACHINE_WORD_3, NID_MACHINE_WORD_4, NID_MACHINE_WORD_5, NID_MACHINE_WORD_6
    global NID_MACHINE_WORD_7, NID_MACHINE_WORD_8, NID_MACHINE_WORD_MINUS_1, NID_MACHINE_WORD_INT_MIN

    global NID_LSB_MASK, SID_DOUBLE_MACHINE_WORD

    SID_BOOLEAN = new_boolean()

    NID_FALSE = new_constant(OP_CONSTD, SID_BOOLEAN, 0, "false")
    NID_TRUE = new_constant(OP_CONSTD, SID_BOOLEAN, 1, "true")

    SID_BYTE = new_bitvec(8, "8-bit byte")

    NID_BYTE_0 = new_constant(OP_CONSTD, SID_BYTE, 0, "byte 0")
    NID_BYTE_3 = new_constant(OP_CONSTD, SID_BYTE, 3, "byte 3")

    SID_HALF_WORD = new_bitvec(HALFWORDSIZEINBITS, "16-bit half word")

    NID_HALF_WORD_0 = new_constant(OP_CONSTD, SID_HALF_WORD, 0, "half word 0")
    NID_HALF_WORD_1 = new_constant(OP_CONSTD, SID_HALF_WORD, 1, "half word 1")

    SID_SINGLE_WORD = new_bitvec(SINGLEWORDSIZEINBITS, "32-bit single word")

    NID_SINGLE_WORD_0 = new_constant(OP_CONSTD, SID_SINGLE_WORD, 0, "single-word 0")
    NID_SINGLE_WORD_1 = new_constant(OP_CONSTD, SID_SINGLE_WORD, 1, "single-word 1")
    NID_SINGLE_WORD_2 = new_constant(OP_CONSTD, SID_SINGLE_WORD, 2, "single-word 2")
    NID_SINGLE_WORD_3 = new_constant(OP_CONSTD, SID_SINGLE_WORD, 3, "single-word 3")
    NID_SINGLE_WORD_4 = new_constant(OP_CONSTD, SID_SINGLE_WORD, 4, "single-word 4")
    NID_SINGLE_WORD_5 = new_constant(OP_CONSTD, SID_SINGLE_WORD, 5, "single-word 5")
    NID_SINGLE_WORD_6 = new_constant(OP_CONSTD, SID_SINGLE_WORD, 6, "single-word 6")
    NID_SINGLE_WORD_7 = new_constant(OP_CONSTD, SID_SINGLE_WORD, 7, "single-word 7")
    NID_SINGLE_WORD_8 = new_constant(OP_CONSTD, SID_SINGLE_WORD, 8, "single-word 8")

    NID_SINGLE_WORD_MINUS_1 = new_constant(OP_CONSTD, SID_SINGLE_WORD, -1, "single-word -1")
    NID_SINGLE_WORD_INT_MIN = new_constant(OP_CONSTH, SID_SINGLE_WORD, 2**(SINGLEWORDSIZEINBITS - 1), "single-word INT_MIN")

    SID_DOUBLE_WORD = new_bitvec(DOUBLEWORDSIZEINBITS, "64-bit double word")

    NID_DOUBLE_WORD_0 = new_constant(OP_CONSTD, SID_DOUBLE_WORD, 0, "double-word 0")
    NID_DOUBLE_WORD_1 = new_constant(OP_CONSTD, SID_DOUBLE_WORD, 1, "double-word 1")
    NID_DOUBLE_WORD_2 = new_constant(OP_CONSTD, SID_DOUBLE_WORD, 2, "double-word 2")
    NID_DOUBLE_WORD_3 = new_constant(OP_CONSTD, SID_DOUBLE_WORD, 3, "double-word 3")
    NID_DOUBLE_WORD_4 = new_constant(OP_CONSTD, SID_DOUBLE_WORD, 4, "double-word 4")
    NID_DOUBLE_WORD_5 = new_constant(OP_CONSTD, SID_DOUBLE_WORD, 5, "double-word 5")
    NID_DOUBLE_WORD_6 = new_constant(OP_CONSTD, SID_DOUBLE_WORD, 6, "double-word 6")
    NID_DOUBLE_WORD_7 = new_constant(OP_CONSTD, SID_DOUBLE_WORD, 7, "double-word 7")
    NID_DOUBLE_WORD_8 = new_constant(OP_CONSTD, SID_DOUBLE_WORD, 8, "double-word 8")

    NID_DOUBLE_WORD_MINUS_1 = new_constant(OP_CONSTD, SID_DOUBLE_WORD, -1, "double-word -1")

    if IS64BITTARGET:
        NID_DOUBLE_WORD_INT_MIN = new_constant(OP_CONSTH, SID_DOUBLE_WORD, 2**(DOUBLEWORDSIZEINBITS - 1), "double-word INT_MIN")

        SID_MACHINE_WORD = SID_DOUBLE_WORD

        NID_MACHINE_WORD_0 = NID_DOUBLE_WORD_0
        NID_MACHINE_WORD_1 = NID_DOUBLE_WORD_1
        NID_MACHINE_WORD_2 = NID_DOUBLE_WORD_2
        NID_MACHINE_WORD_3 = NID_DOUBLE_WORD_3
        NID_MACHINE_WORD_4 = NID_DOUBLE_WORD_4
        NID_MACHINE_WORD_5 = NID_DOUBLE_WORD_5
        NID_MACHINE_WORD_6 = NID_DOUBLE_WORD_6
        NID_MACHINE_WORD_7 = NID_DOUBLE_WORD_7
        NID_MACHINE_WORD_8 = NID_DOUBLE_WORD_8

        NID_MACHINE_WORD_MINUS_1 = NID_DOUBLE_WORD_MINUS_1
        NID_MACHINE_WORD_INT_MIN = NID_DOUBLE_WORD_INT_MIN
    else:
        # 32-bit system
        SID_MACHINE_WORD = SID_SINGLE_WORD

        NID_MACHINE_WORD_0 = NID_SINGLE_WORD_0
        NID_MACHINE_WORD_1 = NID_SINGLE_WORD_1
        NID_MACHINE_WORD_2 = NID_SINGLE_WORD_2
        NID_MACHINE_WORD_3 = NID_SINGLE_WORD_3
        NID_MACHINE_WORD_4 = NID_SINGLE_WORD_4
        NID_MACHINE_WORD_5 = NID_SINGLE_WORD_5
        NID_MACHINE_WORD_6 = NID_SINGLE_WORD_6
        NID_MACHINE_WORD_7 = NID_SINGLE_WORD_7
        NID_MACHINE_WORD_8 = NID_SINGLE_WORD_8

        NID_MACHINE_WORD_MINUS_1 = NID_SINGLE_WORD_MINUS_1
        NID_MACHINE_WORD_INT_MIN = NID_SINGLE_WORD_INT_MIN

    NID_LSB_MASK = new_constant(OP_CONSTD, SID_MACHINE_WORD, -2, "all bits but LSB set")

    SID_DOUBLE_MACHINE_WORD = new_bitvec(2 * WORDSIZEINBITS, "double machine word")

# kernel interface

MAX_STRING_LENGTH = 128

NID_MAX_STRING_LENGTH = None

SYSCALL_EXIT   = 93;
SYSCALL_BRK    = 214;
SYSCALL_OPENAT = 56;
SYSCALL_OPEN   = 1024 # legacy syscall
SYSCALL_READ   = 63;
SYSCALL_WRITE  = 64;

NID_EXIT_SYSCALL_ID   = None
NID_BRK_SYSCALL_ID    = None
NID_OPENAT_SYSCALL_ID = None
NID_OPEN_SYSCALL_ID   = None
NID_READ_SYSCALL_ID   = None
NID_WRITE_SYSCALL_ID  = None

BYTES_TO_READ = 1

NID_BYTES_TO_READ = None

INPUT_ADDRESS_SPACE = 1

SID_INPUT_ADDRESS = None
SID_INPUT_BUFFER  = None

def init_kernel_interface():
    global NID_MAX_STRING_LENGTH
    global NID_EXIT_SYSCALL_ID, NID_BRK_SYSCALL_ID, NID_OPENAT_SYSCALL_ID
    global NID_OPEN_SYSCALL_ID, NID_READ_SYSCALL_ID, NID_WRITE_SYSCALL_ID
    global NID_BYTES_TO_READ
    global INPUT_ADDRESS_SPACE, SID_INPUT_ADDRESS, SID_INPUT_BUFFER

    NID_MAX_STRING_LENGTH = new_constant(OP_CONSTD, SID_MACHINE_WORD,
        MAX_STRING_LENGTH, "maximum string length")

    NID_EXIT_SYSCALL_ID = new_constant(OP_CONSTD, SID_MACHINE_WORD,
        SYSCALL_EXIT, f"exit syscall ID {SYSCALL_EXIT:b}")
    NID_BRK_SYSCALL_ID = new_constant(OP_CONSTD, SID_MACHINE_WORD,
        SYSCALL_BRK, f"brk syscall ID {SYSCALL_BRK:b}")
    NID_OPENAT_SYSCALL_ID = new_constant(OP_CONSTD, SID_MACHINE_WORD,
        SYSCALL_OPENAT, f"openat syscall ID {SYSCALL_OPENAT:b}")
    NID_OPEN_SYSCALL_ID = new_constant(OP_CONSTD, SID_MACHINE_WORD,
        SYSCALL_OPEN, f"open syscall ID {SYSCALL_OPEN:b}")
    NID_READ_SYSCALL_ID = new_constant(OP_CONSTD, SID_MACHINE_WORD,
        SYSCALL_READ, f"read syscall ID {SYSCALL_READ:b}")
    NID_WRITE_SYSCALL_ID = new_constant(OP_CONSTD, SID_MACHINE_WORD,
        SYSCALL_WRITE, f"write syscall ID {SYSCALL_WRITE:b}")

    NID_BYTES_TO_READ = new_constant(OP_CONSTD, SID_MACHINE_WORD, BYTES_TO_READ, "bytes to read")

    INPUT_ADDRESS_SPACE = calculate_address_space(BYTES_TO_READ, 8)

    SID_INPUT_ADDRESS = new_bitvec(INPUT_ADDRESS_SPACE, f"{INPUT_ADDRESS_SPACE}-bit input address")
    SID_INPUT_BUFFER  = new_array(SID_INPUT_ADDRESS, SID_BYTE, "input buffer")

def get_power_of_two_size_in_bytes(size_in_bits):
    assert size_in_bits % 8 == 0
    size_in_bits = size_in_bits // 8
    assert size_in_bits == 2**int(math.log(size_in_bits, 2))
    return size_in_bits

def calculate_address_space(number_of_bytes, word_size_in_bits):
    if number_of_bytes < 2 * get_power_of_two_size_in_bytes(word_size_in_bits):
        number_of_bytes = 2 * get_power_of_two_size_in_bytes(word_size_in_bits)

    size_in_words = math.ceil(number_of_bytes / get_power_of_two_size_in_bytes(word_size_in_bits))
    address_space = int(math.log(size_in_words, 2))

    if size_in_words > 2**address_space:
        address_space += 1

    return address_space

class Bitvector_State():
    def __init__(self, core, sid, name, initials):
        assert isinstance(sid, Bitvector)
        self.sid = sid
        if core >= 0:
            self.initial = new_constant(OP_CONSTD, self.sid, 0, f"initial core-{core} {name} value")
            self.state = new_input(OP_STATE, self.sid, f"core-{core}-{initials}", f"{sid.size}-bit {name}")
        else:
            self.initial = new_constant(OP_CONSTD, self.sid, 0, f"initial {name} value")
            self.state = new_input(OP_STATE, self.sid, f"{initials}", f"{sid.size}-bit {name}")
        self.init = new_init(self.sid, self.state, self.initial, f"initializing {name}")

    def __str__(self):
        return f"{self.state}"

class Array_State():
    def __init__(self, core, address_sid, element_sid, name, initials):
        assert isinstance(address_sid, Bitvector) and isinstance(element_sid, Bitvector)
        self.address_sid = address_sid
        self.element_sid = element_sid
        self.array_sid = new_array(address_sid, element_sid, f"{address_sid.size}-bit {name} array")
        if core >= 0:
            self.initial = new_constant(OP_CONSTD, element_sid, 0, f"initial core-{core} {name} value")
            self.state = new_input(OP_STATE, self.array_sid, f"core-{core}-{initials}", f"{address_sid.size}-bit {name} of {element_sid.size}-bit bitvectors")
        else:
            self.initial = new_constant(OP_CONSTD, element_sid, 0, f"initial {name} value")
            self.state = new_input(OP_STATE, self.array_sid, f"{initials}", f"{address_sid.size}-bit {name} of {element_sid.size}-bit bitvectors")
        self.init = new_init(self.array_sid, self.state, self.initial, f"initializing {name}")

    def __str__(self):
        return f"{self.state}"

    def load(self, array_nid, address_nid, comment):
        assert array_nid.sid_line == self.array_sid and address_nid.sid_line == self.address_sid
        return new_binary(OP_READ, self.element_sid, array_nid, address_nid, comment)

    def store(self, array_nid, address_nid, value_nid, comment):
        assert array_nid.sid_line == self.array_sid and address_nid.sid_line == self.address_sid and value_nid.sid_line == self.element_sid
        return new_ternary(OP_WRITE, self.array_sid, array_nid, address_nid, value_nid, comment)

class PC(Bitvector_State):
    def __init__(self, core, word_sid):
        super().__init__(core, word_sid, "program counter", 'pc')

class Registers(Array_State):
    def __init__(self, core, word_sid):
        self.SID_REGISTER_ADDRESS = new_bitvec(5, "register address")
        super().__init__(core, self.SID_REGISTER_ADDRESS, word_sid, "register file", 'register-file')
        self.SID_REGISTER_STATE = self.array_sid

    def load_register_value(reg_nid, comment, register_file_nid):
        return self.load(register_file_nid, reg_nid, comment)

    def store_register_value(reg_nid, value_nid, comment, register_file_nid):
        return self.store(register_file_nid, reg_nid, value_nid, comment)

    def get_5_bit_shamt(value_nid):
        return new_ext(OP_UEXT, SID_SINGLE_WORD,
            new_slice(SID_5_BIT_IMM, value_nid, 4, 0, "get 5-bit shamt"),
            SINGLEWORDSIZEINBITS - 5,
            "unsigned-extend 5-bit shamt")

    def get_shamt(value_nid):
        if IS64BITTARGET:
            return new_ext(OP_UEXT, SID_MACHINE_WORD,
                new_slice(SID_6_BIT_IMM, value_nid, 5, 0, "get 6-bit shamt"),
                WORDSIZEINBITS - 6,
                "unsigned-extend 6-bit shamt")
        else:
            return get_5_bit_shamt(value_nid)

class Segment(Array_State):
    def __init__(self, core, address_sid, word_sid, name, initials):
        super().__init__(core, address_sid, word_sid, name, initials)

class Memory():
    def __init__(self, core, memory_bits, word_sid):
        self.SID_VIRTUAL_ADDRESS = new_bitvec(memory_bits, "virtual address")
        self.code = Segment(core, self.SID_VIRTUAL_ADDRESS, word_sid, "code segment", 'code-segment')
        self.data = Segment(core, self.SID_VIRTUAL_ADDRESS, word_sid, "data segment", 'data-segment')
        self.heap = Segment(core, self.SID_VIRTUAL_ADDRESS, word_sid, "heap segment", 'heap-segment')
        self.stack = Segment(core, self.SID_VIRTUAL_ADDRESS, word_sid, "stack segment", 'stack-segment')

    def __str__(self):
        return f"{self.SID_VIRTUAL_ADDRESS.size}-bit virtual memory:\n{self.code}\n{self.data}\n{self.heap}\n{self.stack}"

class Kernel():
    def __init__(self, core, word_sid, memory):
        self.memory = memory
        self.program_break = Bitvector_State(-1, memory.SID_VIRTUAL_ADDRESS, "program break", 'program-break')
        self.file_descriptor = Bitvector_State(-1, word_sid, "file descriptor", 'file-descriptor')
        self.input_buffer = Array_State(-1, SID_INPUT_ADDRESS, SID_BYTE, "input buffer", 'input-buffer')
        self.readable_bytes = Bitvector_State(core, word_sid, "readable bytes", 'readable-bytes')
        self.read_bytes = Bitvector_State(core, word_sid, "read bytes", 'read-bytes')

    def __str__(self):
        return f"kernel:\n{self.program_break}\n{self.file_descriptor}\n{self.input_buffer}\n{self.readable_bytes}\n{self.read_bytes}"

class Core():
    cores = dict()

    def __init__(self, machine_bits, memory_bits):
        self.core = len(Core.cores)
        self.memory = Memory(self.core, memory_bits, SID_MACHINE_WORD)
        self.kernel = Kernel(self.core, SID_MACHINE_WORD, self.memory)
        self.pc = PC(self.core, SID_MACHINE_WORD)
        self.regs = Registers(self.core, SID_MACHINE_WORD)
        self.new_core()

    def __str__(self):
        return f"{self.kernel}\n{self.memory}\ncore-{self.core}:\n{self.pc}\n{self.regs}"

    def new_core(self):
        assert self not in Core.cores
        Core.cores[self.core] = self

class System():
    def __init__(self, machine_bits, memory_bits):
        self.core = Core(machine_bits, memory_bits) # single core for now

    def __str__(self):
        return f"{SID_MACHINE_WORD.size}-bit single-core system:\n{self.core}"

# BTOR2 parser

import re

class syntax_error(Exception):
    def __init__(self, expected, line_no):
        super().__init__(f"syntax error in line {line_no}: {expected} expected")

def tokenize_btor2(line):
    # comment, non-comment no-space printable string,
    # signed integer, binary number, hexadecimal number
    btor2_token_pattern = r"(;.*|[^; \n\r]+|-?\d+|[0-1]|[0-9a-fA-F]+)"
    tokens = re.findall(btor2_token_pattern, line)
    return tokens

def get_token(tokens, expected, line_no):
    try:
        return tokens.pop(0)
    except:
        raise syntax_error(expected, line_no)

def get_decimal(tokens, expected, line_no):
    token = get_token(tokens, expected, line_no)
    if token.isdecimal():
        return int(token)
    else:
        raise syntax_error(expected, line_no)

def get_nid_line(tokens, clss, expected, line_no):
    nid = get_decimal(tokens, expected, line_no)
    if Line.is_defined(nid):
        line = Line.get(nid)
        if isinstance(line, clss):
            return line
        else:
            raise syntax_error(expected, line_no)
    else:
        raise syntax_error(f"defined {expected}", line_no)

def get_bool_or_bitvec_sid_line(tokens, line_no):
    return get_nid_line(tokens, Bitvector, "Boolean or bitvector sort nid", line_no)

def get_bitvec_sid_line(tokens, line_no):
    return get_nid_line(tokens, Bitvec, "bitvector sort nid", line_no)

def get_sid_line(tokens, line_no):
    return get_nid_line(tokens, Sort, "sort nid", line_no)

def get_state_line(tokens, line_no):
    return get_nid_line(tokens, State, "state nid", line_no)

def get_exp_line(tokens, line_no):
    return get_nid_line(tokens, Expression, "expression nid", line_no)

def get_number(tokens, base, expected, line_no):
    token = get_token(tokens, expected, line_no)
    try:
        if (base == 10):
            return int(token)
        else:
            return int(token, base)
    except ValueError:
        raise syntax_error(expected, line_no)

def get_symbol(tokens):
    try:
        return get_token(tokens, None, None)
    except:
        return ""

def get_comment(tokens, line_no):
    comment = get_symbol(tokens)
    if comment != "":
        if comment[0] != ';':
            raise syntax_error("comment", line_no)
    return comment

def parse_sort_line(tokens, nid, line_no):
    token = get_token(tokens, "bitvector or array", line_no)
    if token == Bitvec.keyword:
        size = get_decimal(tokens, "bitvector size", line_no)
        comment = get_comment(tokens, line_no)
        # rotor-dependent Boolean declaration
        if comment == "; Boolean" and size == 1:
            return new_boolean(nid, line_no)
        else:
            return new_bitvec(size, comment, nid, line_no)
    elif token == Array.keyword:
        array_size_line = get_bitvec_sid_line(tokens, line_no)
        element_size_line = get_bitvec_sid_line(tokens, line_no)
        comment = get_comment(tokens, line_no)
        return new_array(array_size_line, element_size_line, comment, nid, line_no)
    else:
        raise syntax_error("bitvector or array", line_no)

def parse_zero_one_line(tokens, nid, op, line_no):
    sid_line = get_bool_or_bitvec_sid_line(tokens, line_no)
    comment = get_comment(tokens, line_no)
    return new_zero_one(op, sid_line, comment, nid, line_no)

def parse_constant_line(tokens, nid, op, line_no):
    sid_line = get_bool_or_bitvec_sid_line(tokens, line_no)
    if op == Constd.keyword:
        value = get_number(tokens, 10, "signed integer", line_no)
    elif op == Const.keyword:
        value = get_number(tokens, 2, "binary number", line_no)
    elif op == Consth.keyword:
        value = get_number(tokens, 16, "hexadecimal number", line_no)
    comment = get_comment(tokens, line_no)
    return new_constant(op, sid_line, value, comment, nid, line_no)

def parse_symbol_comment(tokens, line_no):
    symbol = get_symbol(tokens)
    comment = get_comment(tokens, line_no)
    if symbol != "":
        if symbol[0] == ';':
            return "", symbol
    return symbol, comment

def parse_variable_line(tokens, nid, op, line_no):
    sid_line = get_sid_line(tokens, line_no)
    symbol, comment = parse_symbol_comment(tokens, line_no)
    return new_input(op, sid_line, symbol, comment, nid, line_no)

def parse_ext_line(tokens, nid, op, line_no):
    sid_line = get_sid_line(tokens, line_no)
    arg1_line = get_exp_line(tokens, line_no)
    w = get_decimal(tokens, "bit width", line_no)
    comment = get_comment(tokens, line_no)
    return new_ext(op, sid_line, arg1_line, w, comment, nid, line_no)

def parse_slice_line(tokens, nid, line_no):
    sid_line = get_sid_line(tokens, line_no)
    arg1_line = get_exp_line(tokens, line_no)
    u = get_decimal(tokens, "upper bit", line_no)
    l = get_decimal(tokens, "lower bit", line_no)
    comment = get_comment(tokens, line_no)
    return new_slice(sid_line, arg1_line, u, l, comment, nid, line_no)

def parse_unary_line(tokens, nid, op, line_no):
    sid_line = get_sid_line(tokens, line_no)
    arg1_line = get_exp_line(tokens, line_no)
    comment = get_comment(tokens, line_no)
    return new_unary(op, sid_line, arg1_line, comment, nid, line_no)

def parse_binary_line(tokens, nid, op, line_no):
    sid_line = get_sid_line(tokens, line_no)
    arg1_line = get_exp_line(tokens, line_no)
    arg2_line = get_exp_line(tokens, line_no)
    comment = get_comment(tokens, line_no)
    return new_binary(op, sid_line, arg1_line, arg2_line, comment, nid, line_no)

def parse_ternary_line(tokens, nid, op, line_no):
    sid_line = get_sid_line(tokens, line_no)
    arg1_line = get_exp_line(tokens, line_no)
    arg2_line = get_exp_line(tokens, line_no)
    arg3_line = get_exp_line(tokens, line_no)
    comment = get_comment(tokens, line_no)
    return new_ternary(op, sid_line, arg1_line, arg2_line, arg3_line, comment, nid, line_no)

def parse_init_next_line(tokens, nid, op, line_no):
    sid_line = get_sid_line(tokens, line_no)
    state_line = get_state_line(tokens, line_no)
    exp_line = get_exp_line(tokens, line_no)
    comment = get_comment(tokens, line_no)
    return new_init_next(op, sid_line, state_line, exp_line, comment, nid, line_no)

def parse_property_line(tokens, nid, op, line_no):
    property_line = get_exp_line(tokens, line_no)
    symbol, comment = parse_symbol_comment(tokens, line_no)
    return new_property(op, property_line, symbol, comment, nid, line_no)

def parse_btor2_line(line, line_no):
    current_nid = 0

    if line.strip():
        tokens = tokenize_btor2(line)
        token = get_token(tokens, None, None)
        if token[0] != ';':
            if token.isdecimal():
                nid = int(token)
                if nid > current_nid:
                    current_nid = nid
                    token = get_token(tokens, "keyword", line_no)
                    if token == Sort.keyword:
                        return parse_sort_line(tokens, nid, line_no)
                    elif token in {Zero.keyword, One.keyword}:
                        return parse_zero_one_line(tokens, nid, token, line_no)
                    elif token in {Constd.keyword, Const.keyword, Consth.keyword}:
                        return parse_constant_line(tokens, nid, token, line_no)
                    elif token in Variable.keywords:
                        return parse_variable_line(tokens, nid, token, line_no)
                    elif token in Ext.keywords:
                        return parse_ext_line(tokens, nid, token, line_no)
                    elif token == Slice.keyword:
                        return parse_slice_line(tokens, nid, line_no)
                    elif token in Unary.keywords:
                        return parse_unary_line(tokens, nid, token, line_no)
                    elif token in Binary.keywords:
                        return parse_binary_line(tokens, nid, token, line_no)
                    elif token in Ternary.keywords:
                        return parse_ternary_line(tokens, nid, token, line_no)
                    elif token in {Init.keyword, Next.keyword}:
                        return parse_init_next_line(tokens, nid, token, line_no)
                    elif token in Property.keywords:
                        return parse_property_line(tokens, nid, token, line_no)
                    else:
                        raise syntax_error(f"unknown operator {token}", line_no)
                raise syntax_error("increasing nid", line_no)
            raise syntax_error("nid", line_no)
    return line.strip()

def parse_btor2(modelfile):
    line_no = 1
    for line in modelfile:
        try:
            parse_btor2_line(line, line_no)
            line_no += 1
        except Exception as message:
            print(message)
            exit(1)

    for state in State.states.values():
        if state.init_line == state:
            # state has no init
            state.new_input()

# Z3 and bitwuzla solver interface

class Solver():
    def __init__(self, solver):
        self.solver = solver

    def push(self):
        self.solver.push()

    def pop(self):
        self.solver.pop()

class Z3_Solver(Solver):
    def __init__(self):
        super().__init__(z3.Solver())

    def assert_this(self, assertion, step):
        self.solver.add(assertion.get_z3_step(step))

    def assert_not_this(self, assertion, step):
        self.solver.add(assertion.get_z3_step(step) == False)

    def prove(self):
        return self.solver.check()

    def is_SAT(self, result):
        return result == z3.sat

    def is_UNSAT(self, result):
        return result == z3.unsat

    def assert_change(self, next_line, step):
        return self.solver.add(next_line.get_z3_change(step))

    def take_next_step(self, state):
        state.take_z3_step()

    def print_pc(self, pc, step):
        self.prove()
        model = self.solver.model()
        for decl in model.decls():
            if str(pc.get_z3_step(step)) in str(decl.name()):
                pc_value = int(model[decl].as_long())
                print(pc)
                print("%s = 0x%X" % (decl.name(), pc_value))

    def print_inputs(self, inputs, step):
        model = self.solver.model()
        for input_variable in inputs.values():
            # only print value of uninitialized states
            print(input_variable)
            for decl in model.decls():
                if str(input_variable.get_z3_step(step)) in str(decl.name()):
                    print("%s = %s" % (decl.name(), model[decl]))

class Bitwuzla_Solver(Solver):
    def __init__(self):
        self.tm = bitwuzla.TermManager()
        self.options = bitwuzla.Options()
        self.options.set(bitwuzla.Option.PRODUCE_MODELS, True)
        super().__init__(bitwuzla.Bitwuzla(self.tm, self.options))

    def assert_this(self, assertion, step):
        self.solver.assert_formula(assertion.get_bitwuzla_step(step, self.tm))

    def assert_not_this(self, assertion, step):
        self.solver.assert_formula(self.tm.mk_term(bitwuzla.Kind.NOT, [assertion.get_bitwuzla_step(step, self.tm)]))

    def prove(self):
        return self.solver.check_sat()

    def is_SAT(self, result):
        return result is bitwuzla.Result.SAT

    def is_UNSAT(self, result):
        return result is bitwuzla.Result.UNSAT

    def assert_change(self, next_line, step):
        return self.solver.assert_formula(next_line.get_bitwuzla_change(step, self.tm))

    def take_next_step(self, state):
        state.take_bitwuzla_step(self.tm)

    def print_pc(self, pc, step):
        self.prove()
        pc_value = int(self.solver.get_value(pc.get_bitwuzla_step(step, self.tm)).value(16), 16)
        print(pc)
        print("%s = 0x%X" % (pc.get_bitwuzla_step(step, self.tm), pc_value))

    def print_inputs(self, inputs, step):
        for input_variable in inputs.values():
            # only print value of uninitialized states
            print(input_variable)
            print("%s = %s" % (input_variable.get_bitwuzla_step(step, self.tm),
                self.solver.get_value(input_variable.get_bitwuzla_step(step, self.tm))))

# bitme bounded model checker

def bmc(solver, kmin, kmax, args):
    for init in Init.inits.values():
        # initialize all states
        solver.assert_this(init, 0)

    step = 0

    while step <= kmax:
        # check model up to kmax steps
        print(step)

        if args.print_pc and State.pc:
            # print current program counter value of single-core rotor model
            solver.print_pc(State.pc, step)

        for constraint in Constraint.constraints.values():
            # assert all constraints
            solver.assert_this(constraint, step)

        if step >= kmin:
            # check bad properties from kmin on
            for bad in Bad.bads.values():
                # check all bad properties
                solver.push()
                solver.assert_this(bad, step)
                result = solver.prove()
                if solver.is_SAT(result):
                    print("v" * 80)
                    print(f"sat: {bad}")
                    solver.print_inputs(Variable.inputs, step)
                    print("^" * 80)
                solver.pop()

        for bad in Bad.bads.values():
            # assert all bad properties as negated constraints
            solver.assert_not_this(bad, step)

        for next_line in Next.nexts.values():
            # compute next step
            solver.assert_this(next_line, step)

        if args.check_termination and step >= kmin:
            state_change = False
            for next_line in Next.nexts.values():
                # check if any of the states changes
                solver.push()
                solver.assert_change(next_line, step)
                result = solver.prove()
                solver.pop()
                if solver.is_SAT(result):
                    state_change = True
                    print(f"state change: {next_line}")
                    # break for efficiency
                if not state_change and next_line == list(Next.nexts.values())[-1]:
                    print("no states changed: terminating")
                    return

        for state in State.states.values():
            # take next step
            solver.take_next_step(state)

        step += 1

# rotor model generator

import sys

def try_rotor():
    if is_rotor_present and len(sys.argv) > 1 and sys.argv[1] == '--rotor':
        # just run rotor
        argv = [sys.argv[0]] + sys.argv[2:] # remove --rotor but keep all other arguments
        rotor.main.argtypes = ctypes.c_int, ctypes.POINTER(ctypes.c_char_p)
        rotor.main(len(argv), (ctypes.c_char_p * len(argv))(*[arg.encode('utf-8') for arg in argv]))
        exit(0)

import argparse

def main():
    try_rotor()

    parser = argparse.ArgumentParser(prog='bitme',
        description="What the program does",
        epilog="Text at the bottom of help")

    parser.add_argument('modelfile')

    parser.add_argument('-kmin', nargs=1, type=int)
    parser.add_argument('-kmax', nargs=1, type=int)

    parser.add_argument('--use-Z3', action='store_true')
    parser.add_argument('--use-bitwuzla', action='store_true')

    parser.add_argument('--print-pc', action='store_true')
    parser.add_argument('--check-termination', action='store_true')

    args = parser.parse_args()

    with open(args.modelfile) as modelfile:
        parse_btor2(modelfile)

    if args.kmin or args.kmax:
        kmin = args.kmin[0] if args.kmin else 0
        kmax = args.kmax[0] if args.kmax else 0

        kmax = max(kmin, kmax)

        if is_Z3_present and args.use_Z3:
            solver = Z3_Solver()
            bmc(solver, kmin, kmax, args)

        if is_bitwuzla_present and args.use_bitwuzla:
            solver = Bitwuzla_Solver()
            bmc(solver, kmin, kmax, args)

if __name__ == '__main__':
    main()